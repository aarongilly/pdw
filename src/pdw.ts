import { Temporal } from "temporal-polyfill";

//#region ### TYPES ###

/**
 * A alias for string, implying one with the structure of:
 * {@link EpochStr}-{@link SmallID}
 */
export type UID = string;

/**
 * A alias for string, a string of 4 random characters
 * generated by the {@link makeSmallID} function
 */
export type SmallID = string;

/**
 * An alias for string, a string that's made from the number of 
 * milliseconds that have occurred since the epoch, stored in base 36
 * A short, consistenty way to track timezone-dependent fields like
 * {@link _created} and {@link _updated} that isn't 
 * subject to alternative interpretations by, say, Excel
 */
export type EpochStr = string;

/**
 * An alias for string, a string that can be parsed by
 * Temporal.Duration.from()
 * Example: 
 * `P3D6H30M`
 */
export type DurationStr = string;

/**
 * A alias for string, any valid Period.toString() string
 */
export type PeriodStr = string;

/**
 * An alias for string, intended to be markdown-enabled in use
 */
export type Markdown = string

//#endregion

//#region ### ENUMS ###

export enum PointType {
    /**
     * a number
     */
    NUMBER = "NUMBER",
    /**
     * A string, assumed to be short-ish
     */
    TEXT = 'TEXT',
    /**
     * A string, assumed to be long-ish, to run through 'marked' if possible
     */
    MARKDOWN = 'MARKDOWN',
    /**
     * Essentially an enumeration
     */
    SELECT = 'SELECT',
    /**
     * true or false
     */
    BOOL = 'BOOL', //true false
    /**
     * A Temporal Duration string, starting with the 'P' (and usually also 'T') to really ensure no ambiguity
     * P3M = 3 Months
     * PT3M = 3 Minutes
     */
    DURATION = 'DURATION',
    /**
     * A Temporal PlainTime string (no timezone)
     */
    TIME = 'TIME', //Temporal.plainTime
    /**
     * An array of _tid
     */
    MULTISELECT = 'MULTISELECT', //Comma-separated list of _tid 
    /**
     * A url to a file?
     */
    FILE = 'FILE', //url?
    /**
     * A url to a photo?
     */
    PHOTO = 'PHOTO', //url?
    /**
     * Literally JSON - circular references are **not** supported. You have to be able to run JSON.parse(JSON.stringify(Entry))
     */
    JSON = 'JSON'
}

/**
 * Level of granularity. Assigned to each {@link Def}
 */
export enum Scope {
    SECOND = 'SECOND',
    MINUTE = 'MINUTE',
    HOUR = 'HOUR',
    DAY = 'DAY',
    WEEK = 'WEEK',
    MONTH = 'MONTH',
    QUARTER = 'QUARTER',
    YEAR = 'YEAR',
}

/**
 * Default operation to apply when performing a {@link PointRollup}. 
 * Each {@link PointDef} is associated with one Rollup.
 */
export enum Rollup {
    COUNT = 'COUNT',
    COUNTUNIQUE = 'COUNTUNIQUE',
    SUM = 'SUM',
    AVERAGE = 'AVERAGE',
    COUNTOFEACH = 'COUNTOFEACH',
}

//#endregion

//#region ### INTERFACES ###

/**
 * The `DataStore` interface is what you must implement when creating code to
 * hook up a new database. It is what sits between the database of choice and the PDW.
 * It's designed to be as simple-to-implement as possible.
 * 
 * The parameter sanitization & merge logic are handled by the PDW.
 * 
 * It's *very much* a work in progress.
 */
export interface DataStore {
    commit(trans: Transaction): Promise<CommitResponse>;

    getEntries(params: ReducedParams): Promise<ReducedQueryResponse>;

    getDefs(includeDeletedForArchiving?: boolean): Promise<DefData[]>;

    getOverview(): Promise<DataStoreOverview>;

    connect(...params: any): Promise<boolean>;

    /**
     * The name of the connector, essentially. Examples: "Excel", "Firestore"
     */
    serviceName: string;

    /**
     * A reference to the Personal Data Warehouse instance to 
     * which the storage connector is connected.
     */
    pdw?: PDW;
}

/**
 * A static DataStore. Loads content to the DefaultDataStore (arrays in memory)
 * and doesn't register itself with the PDW. No changes are persisted to the 
 * place where the data was imported from until it's exported back to that place.
 */
export interface AsyncDataStore {
    importFrom(params: any): Promise<CompleteDataset>,
    exportTo(allData: CompleteDataset, params: any): any
}

/**
 * Basic data filtering parameters, supported by the {@link PDW} methods for
 * {@link getDefs} & the 2 other element "getters". The {@link DataStore} methods
 * will get {@link ReducedParams} passed to them by the PDW methods, which will
 * perform the sanitization.
 * Not all parameters are considered for each getter, but it should make
 * things a bit simpler to standardize the params
 */
export interface StandardParams {
    /**
     * Include things marked as deleted?
     * no - default
     * yes - include all
     * only - only include deleted things
     */
    includeDeleted?: 'yes' | 'no' | 'only',
    /**
     * Lower-bound of Entry.period.
     * Like all Periods, does not contain Time Zone info.
     * Will be treated as the FIRST SECOND of the Period or PeriodStr provided.
     * Example:
     * "2023-Q2" would be synonymous with "2023-04-01T:00:00:00"
     */
    from?: Period | PeriodStr,
    /**
     * Upper-bound of Entry.period. 
     * Like all Periods, does not contain Time Zone info.
     * Will be treated as the LAST SECOND of the Period or PeriodStr provided.
     * Example:
     * "2023-Q2" would be synonymous with "2023-08-31T:23:59:59"
     */
    to?: Period | PeriodStr,
    /**
     * Entry period. Sets the Query.from and Query.to values internally.
     */
    inPeriod?: Period | string
    /**
     * The lower-bound of Element.created, represented as an {@link EpochStr}
     * or Temporal.ZonedDateTime. 
     */
    createdAfter?: Temporal.ZonedDateTime | EpochStr,
    /**
     * The upper-bound of Element.created, represented as an {@link EpochStr}
     * or Temporal.ZonedDateTime. 
     */
    createdBefore?: Temporal.ZonedDateTime | EpochStr,
    /**
     * The lower-bound of Element.updated, represented as an {@link EpochStr}
     * or Temporal.ZonedDateTime. 
     */
    updatedAfter?: Temporal.ZonedDateTime | EpochStr,
    /**
     * The upper-bound of Element.updated, represented as an {@link EpochStr}
     * or Temporal.ZonedDateTime. 
     */
    updatedBefore?: Temporal.ZonedDateTime | EpochStr,
    /**
     * A list of Element.uid. Will filter to Elements in the list.
     */
    uid?: UID[] | UID,
    /**
     * A list of {@link SmallID}.
     * For Entry and Def elements, will return those with Element.did in the list.
     */
    did?: SmallID[] | SmallID,
    /**
     * A list of {@link UID}.
     * Will return any Entry instance(s) whose Entry.eid is in the list.
     */
    eid?: UID[] | UID,
    /**
     * A list of strings for the associated with Def.lbl
     * Internally, this is translated into a list of _did strings, and behaves like
     * {@link StandardParams.did}
     * For Entry and Def elements, will return those with Element.did in the list.
     */
    defLbl?: string[] | string,
    //pointLbl?: string[] | string, do you want to support this
    /**
     * A list of strings.
     * Will return any Tag(s) whose Tag.lbl is in the list.
     */
    tag?: string,
    /**
     * Reduces the resulting {@link Def} and {@link} Entry results to those whose
     * scope is in the provided list.
     */
    scope?: Scope | Scope[];
    /**
     * A limit on the number of responses returned. Probably unsorted and therefore
     * not super helpful, but this is something I'd like to support.
     */
    limit?: number,//#TODO
    /**
     * If an empty query is sent without this field, the query is rejected.
     * This is prevent the error trap of accidentally asking for *everything*,
     * which could be expensive in cloud-based datastores.
     */
    allOnPurpose?: boolean
    /**
     * If provdided, will query for the current day. Will ignore any provided values
     */
    today?: any;
    /**
     * If provdided, will query for the current week. Will ignore any provided values
     */
    thisWeek?: any;
    /**
     * If provdided, will query for the current month. Will ignore any provided values
     */
    thisMonth?: any;
    /**
     * If provdided, will query for the current quarter. Will ignore any provided values
     */
    thisQuarter?: any;
    /**
     * If provdided, will query for the current year. Will ignore any provided values
     */
    thisYear?: any;
    /**
     * If provided, the query response will include Period rollups
     */
    rollup?: Scope
}

/**
 * A more tightly-controlled version of the {@link StandardParams}, meant to make
 * development of any new {@link DataStore} **EASIER** to implement. SanitizedParams are
 * what DataStore versions of the main setter/getter functions respond to.  
 */
export interface ReducedParams {
    /**
     * yes - excludes deleted stuff
     * no - returns deleted & undeleted stuff
     * only - returns **only** deleted stuff
     */
    includeDeleted: 'yes' | 'no' | 'only',
    from?: Period,
    to?: Period,

    //these 4 pairs come in pairs from the sanitizeParams() func, DataStore could use either
    createdAfter?: Temporal.ZonedDateTime,
    createdAfterEpochStr?: EpochStr,

    createdBefore?: Temporal.ZonedDateTime,
    createdBeforeEpochStr?: EpochStr,

    updatedBefore?: Temporal.ZonedDateTime
    updatedBeforeEpochStr?: EpochStr,

    updatedAfter?: Temporal.ZonedDateTime,
    updatedAfterEpochStr?: EpochStr,

    uid?: UID[],
    did?: SmallID[],
    eid?: UID[],
    defLbl?: string[],
    pointLbl?: string[],

    limit?: number, //#TODO
    /**
     * Reduces the resulting {@link Def} and {@link} Entry results to those whose
     * scope is in the provided list.
     */
    scope?: Scope[];
    allOnPurpose?: boolean
}

export interface ElementDataMap {
    defs: DefData[];
    entries: EntryData[];
}

export interface ElementMap {
    defs: Def[];
    entries: Entry[];
}

/**
 * 
    overview?: DataStoreOverview
    storeName?: string;
    defs: CurrentAndDeletedCounts;
    entries: CurrentAndDeletedCounts;
    lastUpdated: EpochStr;
 */
export interface CompleteDataset extends ElementDataMap {
    overview?: DataStoreOverview;
}

export interface Transaction {
    create: ElementMap;
    update: ElementMap;
    delete: DeletionMsgMap;
}

export interface DeletionMsg {
    uid: UID;
    deleted: boolean;
    updated: EpochStr;
}

export interface DeletionMsgMap {
    defs: DeletionMsg[];
    entries: DeletionMsg[];
}

/**
 * This interface is extended by the interfaces for the base Elements
 */
export interface ElementLike {
    /**
     * Universal ID - uniquely identifies an INSTANCE of any element.
     */
    _uid?: UID;
    /**
     * Was the element marked as deleted?
     * For things like "_did" or "_pid", "_tid", you may have multiple
     * instances with the same value, but you'll tell them apart using
     * the _uid --- and only **one** will have _deleted == false
     */
    _deleted?: boolean;
    /**
     * When the element was created
     */
    _created?: EpochStr;
    /**
     * When the element was updated, usually lines up with "_created"
     * unless the instance of the element was created via updating a 
     * previous instance
     */
    _updated?: EpochStr;
    /**
     * other key/value pairs will attempt to find
     * the PointDef who's _pid == the key and spin
     * up a new {@link EntryPoint} who's _val is 
     * the value
     */
    [x: string]: any;
}

// export interface Element {
//     _uid: UID;
//     _deleted: boolean;
//     _created: EpochStr;
//     _updated: EpochStr;
// }

/**
 * Definitions Data Shape
 */
export interface DefLike extends ElementLike {
    /**
     * Definition ID - the type of the thing.
     */
    _did?: string;
    /**
     * The label for the definition
     */
    _lbl?: string;
    /**
     * A text string describing what the definition is for
     */
    _desc?: string;
    /**
     * A shorthand for the definition
     */
    _emoji?: string;
    /**
     * Scope of the definition (e.g. "day", "week"...)
     */
    _scope?: Scope;
    /**
     * For things you want to collect, but not necessarily see
     */
    _tags?: string[];
    /**
     * The points on the definition
     */
    _pts?: PointDefLike[];
}

export interface PointDefLike {
    /**
     * Point Definition ID.
     */
    _pid?: SmallID
    /**
    * Label for the point
    */
    _lbl?: string;
    /**
    * Point description
    */
    _desc?: string;
    /**
     * Shorthand for the point in the UI
     */
    _emoji?: string;
    /**
    * Point type
    */
    _type?: PointType;
    /**
     * Default rollup type
     */
    _rollup?: Rollup;
    /**
     * PointDefs cannot be *deleted*, only deactivated
     */
    _hide?: boolean;
    /**
     * Select & Multiselect options. Associated with a option ID (an {@link SmallID})
     */
    _opts?: OptMap;
    // [x: string]: any;
}

export interface EntryLike extends ElementLike {
    /**
     * Entry ID, a unique identifier for an entry - unlike {@link _uid} 
     * _eid is not updated when an entry is updated. A new _uid is created
     * for the updated Entry, but they will share _eid values.
     */
    _eid?: UID,
    /**
     * A generic note about an entry, all entries can have them
     */
    _note?: string,
    /**
     * When the entry is for
     */
    _period?: PeriodStr,
    /**
     * Associated definition ID
     */
    _did?: SmallID,
    /**
     * For tracking where the tracking is coming from
     */
    _source?: string,

    /**
     * _pid keys, with the value of the EntryPoint
     */
    [_pid: string]: any
}

export interface ElementData {
    _uid: UID;
    _deleted: boolean;
    _created: EpochStr;
    _updated: EpochStr;
    [x: string]: any;
}

export interface DefData extends ElementData {
    _did: string;
    _lbl: string;
    _desc: string;
    _emoji: string;
    _tags: string[];
    _scope: Scope;
    _pts: PointDefData[];
}

export interface PointDefData {
    _pid: SmallID
    _lbl: string;
    _desc: string;
    _emoji: string;
    _type: PointType;
    _rollup: Rollup;
    _hide: boolean;
    _opts: OptMap;
}

export interface EntryData extends ElementData {
    _eid: UID,
    _note: string,
    _period: PeriodStr,
    _did: SmallID,
    _source: string,
    [_pid: string]: any
}

export interface PointRollup {
    pid: SmallID;
    lbl: string;
    val: any;
    method: Rollup;
    vals: any[];
}

export interface EntryRollup {
    did: SmallID;
    lbl: string;
    emoji: string;
    pts: PointRollup[];
}

export interface PeriodSummary {
    period: PeriodStr | "ALL";
    entryRollups: EntryRollup[];
    entries: EntryData[]
}

/**
 * Option object, map with key = _oid, val = text label for option
 */
export interface OptMap {
    [_oid: SmallID]: string;
}

export interface QueryResponse {
    success: boolean;
    count: number;
    msgs?: string[];
    params: { paramsIn: object, asParsed: object };
    entries: Entry[];
    summary?: PeriodSummary[];
    // defs: Def[]; //maybe not needed? Entry contains Def
}

export interface ReducedQueryResponse {
    success: boolean;
    entries: EntryData[];
    msgs?: string[];
}

export interface CommitResponse {
    success: boolean;
    msgs?: string[]
}

interface CurrentAndDeletedCounts {
    /**
     * undefined means zero
     */
    current: number | undefined,
    /**
     * undefined means zero
     */
    deleted: number | undefined
}

export interface DataStoreOverview {
    storeName?: string;
    defs: CurrentAndDeletedCounts;
    entries: CurrentAndDeletedCounts;
    lastUpdated: EpochStr;
}

//#endregion

//#region ### CLASSES ###

export class PDW {
    dataStore: DataStore;
    private _manifest: Def[];
    private static instance: PDW;
    private constructor(store?: DataStore) {
        if (store !== undefined) {
            this.dataStore = store;
        } else {
            this.dataStore = new DefaultDataStore(this);
        }
        PDW.instance = this; //for singleton
        this._manifest = [];
    }

    /**
     * Singleton pattern.
     * @returns the PDW
     */
    public static getInstance(): PDW {
        if (!PDW.instance) {
            PDW.instance = new PDW();
        }
        return PDW.instance;
    }

    public static getManifest(): Def[] {
        return this.getInstance()._manifest;
    }

    public get manifest(): Def[] {
        return this._manifest;
    }

    /**
     * Removes any existing DataStore(s) and uses the provided one
     * @param storeInstance the DataStore to use
     */
    async setDataStore(storeInstance: DataStore) {
        this.dataStore = storeInstance;
        this._manifest = (await storeInstance.getDefs()).map(defData => new Def(defData));
    }

    /**
     * 
     * @param rawParams an object of any {@link StandardParams} to include
     * @returns a {@link CompleteDataset} containing a {@link Def}s, {@link Entry}s
     */
    async getAll(rawParams: StandardParams): Promise<CompleteDataset> {
        const params = PDW.sanitizeParams(rawParams);
        const entries = await this.dataStore.getEntries(params);
        const includeDeletedDefs = params.hasOwnProperty('includeDeleted') && params.includeDeleted != 'no';
        const defs = (await this.dataStore.getDefs(includeDeletedDefs)) as DefData[];

        const dataset: CompleteDataset = {
            defs: defs,
            entries: entries.entries
        }

        return PDW.addOverviewToCompleteDataset(dataset);
    }

    /**
     * Grabs the Defs from the attached DataStore. 
     * By default, does not include the deleted defs.
     * If you want to include *all* defs, pass in `true`
     * @param includedDeleted false by default
     * @returns Defs inflated from the DataStore
     */
    async getDefs(includedDeleted = false): Promise<Def[]> {
        const defDatas = await this.dataStore.getDefs(includedDeleted);
        let defs = defDatas.map(dl => new Def(dl));
        return defs;

        // //#TODO - extract this logic to a dedicated "PDW.sync(datastores:DataStore[])" method
        // let combinedDefs: Def[] = [];
        // //compile defs from all attached DataStores
        // this.dataStore.forEach(async dataStore => {
        //     let thisStoreDefDatas = await dataStore.reducedQuery(params);
        //     let thisStoreDefs = thisStoreDefDatas.defs.map(tsdl => new Def(tsdl));
        //     thisStoreDefs.forEach(def => {
        //         let existingCopy = combinedDefs.find(cd => cd.sameIdAs(def.data));
        //         if (existingCopy !== undefined) {
        //             //duplicate found, determine which is newer & keep only it
        //             if (existingCopy.shouldBeReplacedWith(def.data)) {
        //                 //find & remove exising
        //                 const ind = combinedDefs.findIndex(el => el.data._uid === existingCopy!.data._uid)
        //                 combinedDefs.splice(ind);
        //                 //add replacement
        //                 combinedDefs.push(def);
        //             }
        //             //else{ignore it. don't do anything}
        //         } else {
        //             combinedDefs.push(def);
        //         }
        //     })
        // })
        // return combinedDefs;
    }

    getFromManifest(did: string): Def {
        const matchedDef = this.manifest.find(d => d.data._did === did);
        if (matchedDef === undefined) throw new Error("No Def found in Manifest with id: " + did);
        return matchedDef!
    }

    private pushDefsToManifest(defs: Def[]) {
        if (!Array.isArray(defs)) return;
        if (defs.length === 0) return;
        defs.forEach((def: any) => {
            //find def with the same _did, if you find it, replace it
            //if you don't, add it
            const existsAt = this.manifest.findIndex(mD => mD.data._did === def.data._did);
            if (existsAt === -1) this.manifest.push(def);
            if (existsAt !== -1) this.manifest[existsAt] = def;
        })
    }

    private async handleManifestDeletionChange(deles: DeletionMsg[]) {
        if (!Array.isArray(deles)) deles = [deles];
        const deletions = deles.filter(d => d.deleted);
        const undeletions = deles.filter(d => !d.deleted);
        this._manifest = this.manifest.filter(md => !deletions.some(d => d.uid === md.data._uid));
        if (undeletions.length > 0) {
            this.manifest.push(...(await PDW.getInstance().getDefs(false)));
        }
    }

    query(params?: StandardParams): Query {
        return new Query(params);
    }

    async getEntries(rawParams?: StandardParams): Promise<Entry[]> {
        if (rawParams === undefined) rawParams = {};
        const params = PDW.sanitizeParams(rawParams);
        let entriesQuery = await this.dataStore.getEntries(params);
        return PDW.inflateEntriesFromData(entriesQuery.entries);
    }

    async setDefs(createDefs: DefLike[] = [], updateDefs: DefLike[] = [], deletionDefs: DeletionMsg[] = []): Promise<Def[]> {
        let trans: Transaction = {
            create: {
                defs: createDefs.map(def => new Def(def)),
                entries: []
            },
            update: {
                defs: updateDefs.map(def => new Def(def)),
                entries: []
            },
            delete: {
                defs: deletionDefs,
                entries: []
            }
        }
        this.dataStore.commit(trans)
        const defs = [...trans.create.defs, ...trans.update.defs];
        this.handleManifestDeletionChange(trans.delete.defs);
        this.pushDefsToManifest(defs);
        return defs.map(e => e.makeStaticCopy()) as Def[]
    }

    async setEntries(createEntries: EntryData[] = [], updateEntries: EntryData[] = [], deletionEntries: DeletionMsg[] = []): Promise<Entry[]> {

        let trans: Transaction = {
            create: {
                defs: [],
                entries: await PDW.inflateEntriesFromData(createEntries)
            },
            update: {
                defs: [],
                entries: await PDW.inflateEntriesFromData(updateEntries)
            },
            delete: {
                defs: [],
                entries: deletionEntries
            }
        }
        this.dataStore.commit(trans);

        const entries = [...trans.create.entries, ...trans.update.entries];

        return entries.map(e => e.makeStaticCopy()) as Entry[]
    }

    async setAll(completeDataset: CompleteDataset) {
        if (completeDataset.defs !== undefined) this.setDefs(completeDataset.defs);
        if (completeDataset.entries !== undefined) this.setEntries(completeDataset.entries);
    }

    async newDef(defInfo: DefLike): Promise<Def> {
        let newDef = new Def(defInfo);
        const storeCopy = newDef.makeStaticCopy() as Def;
        this.dataStore.commit({
            create: {
                defs: [storeCopy],
                entries: []
            },
            update: {
                defs: [],
                entries: []
            },
            delete: {
                defs: [],
                entries: []
            },
        })
        this.manifest.push(storeCopy);
        return newDef;
    }

    async newEntry(entryInfo: EntryLike, def: Def): Promise<Entry> {
        let newEntry = new Entry(entryInfo, def);
        const storeCopy = newEntry.makeStaticCopy() as Entry;
        this.dataStore.commit({
            create: {
                defs: [],
                entries: [storeCopy]
            },
            update: {
                defs: [],
                entries: []
            },
            delete: {
                defs: [],
                entries: []
            },
        })
        return newEntry;
    }

    /**
     * Converts class instances into standard objects.
     * @param elements Def[], Entry[], or Tag[]
     * @returns DefData[], EntryData[], or TagData[]
     */
    static flatten(elements: Element[]): ElementData[] | DefData[] | EntryData[] {
        return elements.map(e => e.toData());
    }

    /**
     * Combines two complete(ish) datasets ({@link CompleteDataset}). 
     * Returns a CompleteDataset that merges each type of ElementData
     */
    static mergeComplete(a: CompleteDataset, b: CompleteDataset): CompleteDataset {
        let returnObj: CompleteDataset = {
            defs: [],
            entries: []
        };

        if (a.defs.length > 0 && b.defs.length > 0) {
            returnObj.defs = PDW.merge(a.defs, b.defs) as DefData[];
        } else {
            if (a.defs.length > 0) returnObj.defs = a.defs
            if (b.defs.length > 0) returnObj.defs = b.defs
        }
        if (a.entries.length > 0 && b.entries.length > 0) {
            returnObj.entries = PDW.merge(a.entries, b.entries) as EntryData[];
        } else {
            if (a.entries.length > 0) returnObj.entries = a.entries
            if (b.entries.length > 0) returnObj.entries = b.entries
        }
        return returnObj;
    }

    /**
     * Mergest two arrays of elements and returns a static COPY of the combined list
     * without duplicates. Also handles marking things as updated & deleted when they
     * are different in between lists (the most-recently-updated one stays, the rest
     * are marked _deleted = true)
     * @param a list of Elements or ElementData
     * @param b list of Elements or ElementData
     * @returns an array of separate, data-only copies of the merged elements
     */
    static merge(a: ElementData[] | Element[], b: ElementData[] | Element[]): ElementData[] {
        if (a.hasOwnProperty('__modified')) a = a.map(el => el.data);
        if (b.hasOwnProperty('__modified')) b = b.map(el => el.data);
        //make static copy of A
        let result = a.map(e => JSON.parse(JSON.stringify(e)));

        b.forEach(eB => {
            let match = result.find(eA => eA._uid === (<ElementData>eB)._uid);
            if (match !== undefined && match._updated === (<ElementData>eB)._updated) return //result is identical
            if (match !== undefined) {
                if (match._updated! > (<ElementData>eB)._updated!) return //result is newer
                match._updated = (<ElementData>eB)._updated;
                match._deleted = (<ElementData>eB)._deleted;
                return //due to principle of not changing data on update, this makes match equal to eB
            }
            let matches = result.filter(eA => Element.hasSameId(eA, eB as ElementData));
            if (matches.length === 0) {
                result.push(JSON.parse(JSON.stringify(eB)));
                return
            }
            if (matches.length > 1) {
                //keep the most recently updated one
                match = matches.reduce((prev, current) => (prev._updated! > current._updated!) ? prev : current);
            } else {
                match = matches[0]
            }
            if (match !== undefined) {
                if (match._updated! > (<ElementData>eB)._updated) return
                match._deleted = true; //match is outdated by new entry in b
                match._updated = (<ElementData>eB)._created; //this seems appropriate
                //intentionally not returning here, still need to push eB
            }
            result.push(JSON.parse(JSON.stringify(eB)));
        })
        return result;
    }

    /**
     * Enforces defaults. Sanity check some types.
     * Less variability in the output
     * @param params rawParams in
     * @returns santized params out
     */
    static sanitizeParams(params: StandardParams): ReducedParams {
        //ensure default
        if (params.includeDeleted === undefined) params.includeDeleted = 'no';

        if (params?.today !== undefined) params.inPeriod = Period.now(Scope.DAY);
        if (params?.thisWeek !== undefined) params.inPeriod = Period.now(Scope.WEEK);
        if (params?.thisMonth !== undefined) params.inPeriod = Period.now(Scope.MINUTE);
        if (params?.thisQuarter !== undefined) params.inPeriod = Period.now(Scope.QUARTER);
        if (params?.thisYear !== undefined) params.inPeriod = Period.now(Scope.YEAR);

        if (params.hasOwnProperty("inPeriod")) {
            let period = params.inPeriod as Period
            if (typeof params.inPeriod === 'string') period = new Period(params.inPeriod);
            params.from = new Period(period).getStart();
            params.to = new Period(period).getEnd();
        }

        //make periods from period strings
        if (params.from !== undefined) {
            if (typeof params.from === 'string') {
                params.from = new Period(params.from);
            }
            //otherwise I guess I'll assume it's okay
        }
        if (params.to !== undefined) {
            if (typeof params.to === 'string') {
                params.to = new Period(params.to);
            }
            //otherwise I guess I'll assume it's okay
        }

        //make Temporal & EpochStr options
        if (params.createdAfter !== undefined) {
            if (typeof params.createdAfter === 'string') {
                params.createdAfter = parseTemporalFromEpochStr(params.createdAfter);
                (<ReducedParams>params).createdAfterEpochStr = makeEpochStrFrom(params.createdAfter);
            } else {
                (<ReducedParams>params).createdAfterEpochStr = makeEpochStrFrom(params.createdAfter);
                params.createdAfter = parseTemporalFromEpochStr((<ReducedParams>params).createdAfterEpochStr!);
            }
        }
        if (params.createdBefore !== undefined) {
            if (typeof params.createdBefore === 'string') {
                params.createdBefore = parseTemporalFromEpochStr(params.createdBefore);
                (<ReducedParams>params).createdBeforeEpochStr = makeEpochStrFrom(params.createdBefore);
            } else {
                (<ReducedParams>params).createdBeforeEpochStr = makeEpochStrFrom(params.createdBefore);
                params.createdBefore = parseTemporalFromEpochStr((<ReducedParams>params).createdBeforeEpochStr!);
            }
        }
        if (params.updatedAfter !== undefined) {
            if (typeof params.updatedAfter === 'string') {
                params.updatedAfter = parseTemporalFromEpochStr(params.updatedAfter);
                (<ReducedParams>params).updatedAfterEpochStr = makeEpochStrFrom(params.updatedAfter);
            } else {
                (<ReducedParams>params).updatedAfterEpochStr = makeEpochStrFrom(params.updatedAfter);
                params.updatedAfter = parseTemporalFromEpochStr((<ReducedParams>params).updatedAfterEpochStr!);
            }
        }
        if (params.updatedBefore !== undefined) {
            if (typeof params.updatedBefore === 'string') {
                params.updatedBefore = parseTemporalFromEpochStr(params.updatedBefore);
                (<ReducedParams>params).updatedBeforeEpochStr = makeEpochStrFrom(params.updatedBefore);
            } else {
                (<ReducedParams>params).updatedBeforeEpochStr = makeEpochStrFrom(params.updatedBefore);
                params.updatedBefore = parseTemporalFromEpochStr((<ReducedParams>params).updatedBeforeEpochStr!);
            }
        }

        //ensure arrays
        if (params.uid !== undefined && typeof params.uid == 'string') params.uid = [params.uid]
        if (params.eid !== undefined && typeof params.eid == 'string') params.eid = [params.eid]
        if (params.defLbl !== undefined && typeof params.defLbl == 'string') params.did = PDW.getInstance().manifest.filter(def => (<string[]>params.defLbl)!.some(dl => dl === def.lbl)).map(def => def.did);
        if (params.did !== undefined && typeof params.did == 'string') params.did = [params.did]
        if (params.scope !== undefined && typeof params.scope == 'string') params.scope = [params.scope];

        if (params.tag !== undefined && typeof params.tag == 'string') params.did = PDW.getInstance().manifest.filter(def => def.hasTag(params.tag!)).map(def => def.did);

        if (params.limit !== undefined && typeof params.limit !== "number") {
            console.error('Your params were: ', params)
            throw new Error('You tried to supply a limit param with a non-number.')
        }

        return params as ReducedParams
    }

    /**
     * Finds the most-recently updated Element from a {@link CompleteDataset}
     * @returns EpochStr of the most recently-updated thing in the set
     */
    static getDatasetLastUpdate(dataset: CompleteDataset): string {
        let recents: ElementData[] = [];
        if (dataset.defs !== undefined && dataset.defs.length > 0) recents.push(Element.getMostRecent(dataset.defs)!)
        if (dataset.entries !== undefined && dataset.entries.length > 0) recents.push(Element.getMostRecent(dataset.entries)!)
        if (recents.length === 0) return '00000001'
        return Element.getMostRecent(recents)!._updated!
    }

    /**
     * Slap a {@link DatasetOverview} to a {@link CompleteDataset}
     */
    static addOverviewToCompleteDataset(data: CompleteDataset, storeName?: string): CompleteDataset {
        if (data.overview !== undefined) {
            console.warn('Tried to add an overview to a dataset that already had one:', data);
            return data
        }
        data.overview = {
            defs: {
                current: data.defs?.filter(element => element._deleted === false).length,
                deleted: data.defs?.filter(element => element._deleted).length
            },
            entries: {
                current: data.entries?.filter(element => element._deleted === false).length,
                deleted: data.entries?.filter(element => element._deleted).length
            },
            lastUpdated: PDW.getDatasetLastUpdate(data)
        }
        if (storeName) data.overview!.storeName = storeName
        return data
    }

    static inflateEntriesFromData(entryData: EntryData[]): Entry[] {
        let defs = PDW.getInstance().manifest;
        return entryData.map(e => new Entry(e, defs.find(def => def.did === e._did)!));
    }

    /**
     * Takes in an array of {@link Entry} instances and applies the default rollup to 
     * each of the EntryPoints contained in the Entries. Produces an {@link EntryRollup}
     */
    static rollupEntries(entries: EntryData[]): EntryRollup { //#TODO - add RollupOverride param
        const def: Def = PDW.getInstance().getFromManifest(entries[0]._did);
        const pointDefs = def.pts;
        let returnObj = {
            did: def.did,
            lbl: def.lbl,
            emoji: def.emoji,
            pts: [] as PointRollup[]
        }
        pointDefs.forEach(pd => {
            let vals: any[] = [];
            entries.forEach(e => {

                let point = e[pd.pid];
                if (point !== undefined) vals.push(point);
            })
            let ptRlp: PointRollup = {
                pid: pd.pid,
                lbl: pd.lbl,
                method: pd.rollup,
                vals: vals,
                val: undefined
            }
            if (pd.rollup === Rollup.COUNT) ptRlp.val = vals.length;
            if (pd.rollup === Rollup.AVERAGE) {
                const type = pd.type;
                if (type === PointType.NUMBER) ptRlp.val = doAverage(vals);
                if (type === PointType.DURATION) ptRlp.val = doAverageDuration(vals);
                if (type === PointType.TIME) ptRlp.val = doAverageTime(vals);
                if (type !== PointType.NUMBER && type !== PointType.DURATION && type !== PointType.TIME) {
                    console.warn('Tried averaging a point with unsupported type ' + type);
                    ptRlp.val = -1; //hint at an error in the UI
                }
            }
            if (pd.rollup === Rollup.SUM) {
                const type = pd.type;
                if (type === PointType.NUMBER) ptRlp.val = doSum(vals);
                if (type === PointType.DURATION) ptRlp.val = doSumDuration(vals);
            }
            if (pd.rollup === Rollup.COUNTOFEACH) ptRlp.val = doCountOfEach(vals);
            if (pd.rollup === Rollup.COUNTUNIQUE) ptRlp.val = doCountUnique(vals);

            returnObj.pts.push(ptRlp);
        })
        return returnObj

        function doAverage(vals: number[]) {
            let sum = doSum(vals)
            return sum / vals.length;
        }

        function doAverageDuration(vals: string[]): string {
            if (typeof vals[0] !== 'string') throw new Error('Period average saw a non-string')
            // let temp = Temporal.Duration.from(vals[0]).total('seconds');
            const sum = vals.reduce((pv, val) => pv + Temporal.Duration.from(val).total('seconds'), 0);
            const ave = sum / vals.length;
            return Temporal.Duration.from({ seconds: ave }).toLocaleString();
        }

        function doAverageTime(vals: string[]) {// Temporal.PlainTime {
            //want average to be about 4pm, so any time *before* 4pm I add 1-day's worth of seconds to
            let runningTotalInSeconds = 0;
            vals.forEach(val => {
                const time = Temporal.PlainTime.from(val)
                let delta = Temporal.PlainTime.from('00:00:00').until(time)
                const hrs = delta.hours;
                const mins = delta.minutes;
                const secs = delta.seconds;
                //add 24hrs if its before 4am
                if (hrs < 4) runningTotalInSeconds = runningTotalInSeconds + 86400; //add 24 hrs if its before 4am
                runningTotalInSeconds = runningTotalInSeconds + hrs * 3600;
                runningTotalInSeconds = runningTotalInSeconds + mins * 60;
                runningTotalInSeconds = runningTotalInSeconds + secs;

            })
            // let sum = doSum(vals)
            const averageSeconds = Math.round(runningTotalInSeconds / vals.length);
            const timeAverage = Temporal.PlainTime.from('00:00:00').add({ seconds: averageSeconds })
            return timeAverage.toString();
        }

        function doSum(vals: number[]) {
            return vals.reduce((pv, val) => pv + val, 0);
        }

        function doSumDuration(vals: string[]) {
            if (typeof vals[0] !== 'string') throw new Error('Duration average saw a non-string')
            // let temp = Temporal.Duration.from(vals[0]).total('seconds');
            const sum = vals.reduce((pv, val) => pv + Temporal.Duration.from(val).total('seconds'), 0);
            return Temporal.Duration.from({ seconds: sum }).toLocaleString();
        }

        function doCountOfEach(vals: string[]) {
            let strings = [...new Set(vals)];
            let stringCounts = '';
            strings.forEach(str => {
                stringCounts = str + ": " + vals.filter(s => s == str).length + ", " + stringCounts;
            })
            return stringCounts.substring(0, stringCounts.length - 2);
        }

        function doCountUnique(vals: any[]): number {
            return [...new Set(vals)].length;

        }
    }

    static summarize(entries: Entry[] | EntryData[], scope: Scope | "ALL"): PeriodSummary[] {
        if (entries.length === 0) throw new Error("No entries to summarize");
        let entryDataArr = entries as EntryData[];
        if (!entryDataArr[0].hasOwnProperty('_eid')) entryDataArr = entryDataArr.map(e => e.toData()) as EntryData[];
        let periodStrs: PeriodStr[] = [...new Set(entryDataArr.map(e => e._period))];
        let earliest = periodStrs.reduce((prev, periodStr) => {
            const start = new Period(periodStr).getStart().toString();
            return start < prev ? start : prev
        });
        let latest = periodStrs.reduce((prev, periodStr) => {
            const end = new Period(periodStr).getEnd().toString();
            return end > prev ? end : prev
        });
        if (scope === 'ALL') {
            let entsByType = splitEntriesByType(entryDataArr);
            const keys = Object.keys(entsByType);
            let rollups: EntryRollup[] = [];
            keys.forEach(key =>
                rollups.push(PDW.rollupEntries(entsByType[key])))
            return [{
                period: 'ALL',
                entryRollups: rollups,
                entries: entryDataArr
            }];
        }

        let periods = Period.allPeriodsIn(new Period(earliest), new Period(latest), (<Scope>scope), false) as Period[];
        return periods.map(p => {
            let ents = entryDataArr.filter(e => p.contains(e._period));
            let entsByType = splitEntriesByType(ents);
            const keys = Object.keys(entsByType);
            let rollups: EntryRollup[] = [];
            keys.forEach(key =>
                rollups.push(PDW.rollupEntries(entsByType[key])))
            return {
                period: p.toString(),
                entryRollups: rollups,
                entries: ents
            }
        })

        function splitEntriesByType(entries: EntryData[]): { [dids: string]: any; } {
            let entryTypes: { [dids: string]: any; } = {};
            entries.forEach(entry => {
                if (entryTypes.hasOwnProperty(entry._did)) {
                    entryTypes[entry._did].push(entry);
                } else {
                    entryTypes[entry._did] = [entry];
                }
            })
            return entryTypes
        }
    }
}

/**
 * Base class 
 */
export abstract class Element {
    data: ElementData;
    __modified: boolean;
    __deletionChange?: boolean;
    readonly tempCreated: Temporal.ZonedDateTime;
    readonly tempUpdated: Temporal.ZonedDateTime;

    constructor(inputData: ElementLike) {
        this.data = {
            _uid: inputData._uid ?? makeUID(),
            _deleted: Element.handleDeletedInputVariability(inputData._deleted),
            _created: Element.handleEpochStrInputVariability(inputData._created),
            _updated: Element.handleEpochStrInputVariability(inputData._updated)
        }
        this.tempCreated = parseTemporalFromEpochStr(this.data._created);
        this.tempUpdated = parseTemporalFromEpochStr(this.data._updated);
        this.__modified = false;
    }

    /**
     * The unique identifier of the Element instance. Should not have any duplicates 
     * anywhere in the PDW.
     */
    get uid() {
        return this.data._uid;
    }
    /**
     * An {@link EpochStr} describing when the Element was created.
     * If an Element is updated, the _created property will be carried forward.
     */
    get created(): string {
        return this.data._created as string;
    }
    /**
     * An {@link EpochStr} describing when the Element was most recently updated.
     * If an Element is updated, the _updated property will be set to the moment that Element
     * instance was created. The _updated property will also be set to the time the Element
     * class instance was marked as Deleted (or Undeleted).
     */
    get updated(): string {
        return this.data._updated as string;
    }
    /**
    * If an Element should be considered deleted, because things aren't actually *deleted* in 
    * order to make it possible to combine datasets and maintain integrity.
    */
    get deleted() {
        return this.data._deleted;
    }
    set created(newDate: EpochStr | Temporal.ZonedDateTime | Temporal.Instant | Date) {
        this.data._created = Element.handleEpochStrInputVariability(newDate);
        this.__modified = true;
    }
    set updated(newDate: EpochStr | Temporal.ZonedDateTime | Temporal.Instant | Date) {
        this.data._updated = Element.handleEpochStrInputVariability(newDate);
        this.__modified = true;
    }
    set deleted(isDeleted: boolean) {
        this.data._deleted = isDeleted;
        this.__modified = true;
        this.__deletionChange = isDeleted;
    }

    /**
     * Create a **static** copy of the Element's ElementData.
     */
    toData(): ElementData | DefData | EntryData {
        return JSON.parse(JSON.stringify(this.data));
    }

    /**
     * Marks the existing Element as deleted and sends a copy of it with
     * its current property values and a new _uid to the connected {@link DataStore}(s)
     * @returns this
     */
    async save() {
        if (this.__modified === false) {
            console.warn('Tried saving an unchanged Element, ignoring request');
            return;
        }
        const oldId = this.data._uid;
        const changeTime = makeEpochStr();

        let created: ElementLike[] = [];
        let deleted: DeletionMsg[] = [];

        //deletions and un-deletions need to be handled differently, since they don't spawn 
        //new elements to be created. Right now I'm handling it this way.
        if (this.__deletionChange !== undefined) { //indicates 'delete' was changed.
            this.data._updated = changeTime;
            deleted.push({
                uid: this.data._uid,
                deleted: this.data._deleted,
                updated: changeTime
            });
            this.__deletionChange = undefined;

        } else {
            //generate a deletion message for stores
            deleted.push({
                uid: oldId,
                deleted: true,
                updated: changeTime
            });
            this.data._uid = makeUID();
            this.data._updated = changeTime;
            created.push(this.toData());
        }

        //return the 'modified' flag to false to indicate it's not been deleted
        this.__modified = false;

        const elementType = this.getType();
        if (elementType === 'DefData') {
            await PDW.getInstance().setDefs(created, [], deleted);
            return this
        }
        if (elementType === 'EntryData') {
            await PDW.getInstance().setEntries(created as EntryData[], [], deleted)
            return this
        }
        throw new Error('What kind of element is this anyway? ' + elementType)
    }

    isSaved() {
        return !this.__modified;
    }

    setUpdatedToNow() {
        this.data._updated = makeEpochStr();
    }

    /**
     * Checks if the argument was updated more recently than this
     * @param elementData ElementData data to compare against
     * @returns true if argument is updated more recently than this
     */
    isOlderThan(elementData: ElementData | Element) {
        if (elementData.hasOwnProperty('__modified')) return this.data._updated < elementData.updated;
        if (elementData.hasOwnProperty('_updated')) return this.data._updated < (<ElementData>elementData)._updated;
        throw new Error('What props does it have?')
        //ran into a situation one time where I saved something twice on successive
        //lines nad only the first one was taken due to the "strictly olderthan",
        //but I don't want mass overwrites of the same data, so I'm living with
        //that for now.
    }

    /**
     * Checks whether this is the same Element as the comparison AND if the 
     * comparison is newer than this
     * @param comparison ElementData data that might be a newer copy of this
     * @returns true if the argument is a newer version of the same Element
     */
    shouldBeReplacedWith(comparison: ElementData | Element): boolean {
        return Element.shouldReplace(comparison, this.data)
    }

    /**
     * Get the type of an Element.
     * @returns string representing the type of element
     */
    getType(): 'DefData' | 'EntryData' | null {
        return Element.getTypeOfElement(this.data)!
    }

    /**
     * Checks to see if this has the same _did (or _eid, _tid, _pid) as
     * whatever is passed in
     * @param comparison Element to compare against
     */
    sameIdAs(comparison: ElementData | Element) {
        if (comparison.hasOwnProperty('__modified')) return Element.hasSameId(this.data, comparison.data);
        return Element.hasSameId(this.data, (<ElementData>comparison));
    }

    sameTypeAs(comparison: ElementData | Element) {
        if (comparison.hasOwnProperty('__modified')) return this.getType() === Element.getTypeOfElement(comparison.data);
        return this.getType() === Element.getTypeOfElement((<ElementData>comparison));
    }

    passesFilters(params: ReducedParams) {
        if (params.uid !== undefined && !params.uid.some(uid => uid === this.data._uid)) return false;
        if (params.did !== undefined && this.data._did !== undefined && !params.did.some(did => did === this.data._did)) return false;
        if (params.eid !== undefined && this.data._eid !== undefined && !params.eid.some(eid => eid === this.data._eid)) return false;
        // if (params.pid !== undefined && this.data._pid !== undefined && !params.pid.some(pid => pid === this.data._pid)) return false;

        const type = this.getType()!;

        if (params.defLbl !== undefined && type === 'DefData' && !params.defLbl.some(lbl => lbl === this.data._lbl)) return false;

        if (params.createdBeforeEpochStr !== undefined && params.createdBeforeEpochStr < this.data._created) return false;
        if (params.createdAfterEpochStr !== undefined && params.createdAfterEpochStr > this.data._created) return false;

        if (params.updatedBeforeEpochStr !== undefined && params.updatedBeforeEpochStr < this.data._updated) return false;
        if (params.updatedAfterEpochStr !== undefined && params.updatedAfterEpochStr > this.data._updated) return false;

        if (params.includeDeleted === 'no' && this.data._deleted === true) return false;
        if (params.includeDeleted === 'only' && this.data._deleted === false) return false;

        if (type === 'EntryData') {
            if (params.from !== undefined && (<Entry><unknown>this).period.getStart().isBefore(params.from)) return false
            if (params.to !== undefined && (<Entry><unknown>this).period.getEnd().isAfter(params.to)) return false
        }

        return true;
    }

    /**
     * Make a de-referenced COPY of this Element. 
     * NOTE: Not the Element's *data*, that would be the {@link toData} method.
     * @returns an instance of {@link Tag}, {@link Def}, or {@link Entry} that is a de-referenced copy of this
     */
    makeStaticCopy(): Def | Entry {
        const type = Element.getTypeOfElement(this.data);
        const data = this.toData();
        if (type === 'DefData') return new Def(data);
        //@ts-expect-error - Entry instances will have an existing def
        if (type === 'EntryData') return new Entry(data, this.def);
        throw new Error('What type was this? ' + type);
    }

    // extraction & "never nesting" really made this code way more readable... huh
    private static handleDeletedInputVariability(deletedVal: any): boolean {
        if (deletedVal === undefined) return false
        if (typeof deletedVal === 'boolean') return deletedVal;
        if (typeof deletedVal === 'string') return (<string>deletedVal).toUpperCase() === 'TRUE';
        if (typeof deletedVal === 'number') return (<number>deletedVal) === 1 ? true : false
        console.warn(`Didn't know how to set '_deleted' based on input. Defaulting to 'false':`, deletedVal);
        return false
    }

    private static handleEpochStrInputVariability(inputSeen: any): EpochStr {
        if (inputSeen === undefined) return makeEpochStr();
        if (typeof inputSeen === 'string') {
            if (isValidEpochStr(inputSeen)) return inputSeen;
            //try passing through new Date()'s wide-open interpretations
            return makeEpochStrFrom(Temporal.Instant.fromEpochMilliseconds(new Date(inputSeen).getTime()).toZonedDateTimeISO(Temporal.Now.timeZone()))!;
        }
        if (typeof inputSeen === 'number') {
            makeEpochStrFrom(Temporal.Instant.fromEpochMilliseconds(inputSeen).toZonedDateTimeISO(Temporal.Now.timeZone()));
        }
        console.warn('Did not know how to handle parsing this date input, defaulting to now:', inputSeen);
        return makeEpochStr();
    }

    static shouldReplace(thing: ElementData | Element, thingItMayReplace: ElementData | Element): boolean {
        if (thing.hasOwnProperty('__modified')) thing = thing.data
        if (thingItMayReplace.hasOwnProperty('__modified')) thingItMayReplace = thingItMayReplace.data

        if (!Element.hasSameId((<ElementData>thing), (<ElementData>thingItMayReplace))) return false;
        if ((<ElementData>thing)._updated! > (<ElementData>thingItMayReplace)._updated!) return true;
        return false;
    }

    static hasSameId(a: ElementData, b: ElementData): boolean {
        if (a._uid === b._uid) return true;
        const type = Element.getTypeOfElement(a);
        const typeB = Element.getTypeOfElement(b);
        if (type !== typeB) return false;

        if (type === 'DefData') return a._did === b._did;
        if (type === 'EntryData') return a._eid === b._eid;
        throw new Error('type not matched!')
    }

    private static getTypeOfElement(data: ElementData) {
        if (data.hasOwnProperty("_eid")) return "EntryData"
        if (data.hasOwnProperty("_did")) return "DefData"
        return null
    }

    public static getMostRecent(elementArr: ElementData[]): ElementData | undefined {
        if (elementArr.length == 0) {
            console.warn('You tried to get the most recent of a list of zero elements');
            return undefined
        }
        let mostRecent: ElementData = {
            _uid: '',
            _deleted: true,
            _created: '',
            _updated: '0' // earlier than anything before 12/31/1969, 6:00:00PM CST
        }
        elementArr.forEach(element => {
            if (element._updated! > mostRecent._updated!) mostRecent = element
        })
        return mostRecent
    }
}

export class Def extends Element {
    declare data: DefData;
    private readonly _pts: PointDef[];

    constructor(defData: DefLike) {
        if (defData._scope !== undefined && !Def.isValidScope(defData._scope)) throw new Error('Invalid scope supplied when creating Def: ' + defData._scope);
        super(defData);
        this.data = {
            ...this.data,
            _did: defData._did ?? makeSmallID(),
            _lbl: defData._lbl ?? 'Unlabeled Definition',
            _desc: defData._desc ?? 'Set a description',
            _emoji: defData._emoji ?? '',
            _scope: defData._scope ?? Scope.SECOND,
            _tags: defData._tags ?? [],
            _pts: []
        }

        if (this.data._lbl === 'Unlabeled Definition') this.data._lbl = 'Unlabeled Definition ' + this.data._did;

        let pointsToSanitize = defData._pts ?? [];
        //spawn new PointDefs for any non-underscore-prefixed keys
        let pids = Object.keys(defData).filter(key => key.substring(0, 1) !== '_');
        pids.forEach(pid => {
            defData[pid]._pid = pid;
            pointsToSanitize.push(defData[pid]);
        })

        this._pts = pointsToSanitize.map(rawPoint => new PointDef(rawPoint, this));
        this.data._pts = this.pts.map(pd => pd.toData())

        if (!Def.isDefData(this.data)) throw new Error('Def was mal-formed.')
    }
    get did() {
        return this.data._did;
    }
    get lbl() {
        return this.data._lbl;
    }
    get desc() {
        return this.data._desc;
    }
    get emoji() {
        return this.data._emoji;
    }
    get scope() {
        return this.data._scope;
    }
    get tags() {
        return this.data._tags;
    }
    public get pts(): PointDef[] {
        return this._pts;
    }

    set lbl(newLbl: string) {
        this.data._lbl = newLbl;
        this.__modified = true;
    }
    set desc(newDesc: string) {
        this.data._desc = newDesc;
        this.__modified = true;
    }
    set emoji(newEmoji: string) {
        if (!Def.isSingleEmoji(newEmoji)) {
            console.warn('Tried to set an emoji with something that was too long, emoji will not change');
            return
        }
        this.data._emoji = newEmoji;
        this.__modified = true;
    }

    getPoint(pidOrLbl: string): PointDef {
        let point = this.pts.find(point => point.pid === pidOrLbl);
        if (point === undefined) point = this.pts.find(point => point.lbl.toUpperCase() === pidOrLbl.toUpperCase());
        if (point !== undefined) return point
        throw new Error('No point found with pid or lbl when getting "' + pidOrLbl + '" for the Def labeled "' + this.lbl + '"');
    }

    addPoint(pointInfo: PointDefLike): Def {
        let newPoint = new PointDef(pointInfo, this);
        this.pts.push(newPoint);
        this.data._pts.push(newPoint.data)
        this.__modified = true;
        return this
    }

    /**
     * Will return true of the Def has that tag, or the def has a tag in the passed-in array
     */
    hasTag(tag: string[] | string): boolean {
        if (Array.isArray(tag)) return tag.some(item => this.data._tags.includes(item))
        return this.data._tags.some(t => t.toUpperCase() === (<string>tag).toUpperCase());
    }

    addTag(tag: string): Def {
        if (this.data._tags.some(t => t === tag)) {
            console.warn('tried to add already-existing tag to def, ingoring request')
        } else {
            this.data._tags.push(tag);
        }
        return this
    }

    clearTags(): Def {
        this.data._tags = [];
        return this;
    }

    removeTag(tag: string): Def {
        if (this.data._tags.some(t => t === tag)) {
            this.data._tags = this.data._tags.filter(t => t !== tag);
        } else {
            console.warn('tried to remove a non-existant tag from a def, ingoring request')
        }
        return this
    }

    /**
     * Marks the pointDef as _hide = ture
     */
    hidePoint(pointIdentifier: string | PointDef, isUnhide = true) {
        let assPoint: undefined | PointDef
        if (typeof pointIdentifier === undefined) throw new Error("Must send a string or object as a point identifier");
        if (typeof pointIdentifier === 'string') {
            assPoint = this.getPoint(pointIdentifier);
        } else {
            assPoint = pointIdentifier;
            if (!PointDef.isPointDefData(assPoint)) throw new Error("pointIdentifier passed in wasn't PointDefData")
        }
        assPoint.hide = isUnhide;
        this.__modified = true;
    }

    /**
     * Will set _hide = true for the identified point
     * @param pointIdentifier the point to set as active again
     */
    unhidePoint(pointIdentifier: string | PointDef) {
        this.hidePoint(pointIdentifier, false)
    }

    async newEntry(entryData: EntryLike): Promise<Entry> {
        entryData._did = this.did;
        return PDW.getInstance().newEntry(entryData, this);
    }

    /**
    * Predicate to check if an object has all {@link DefData} properties
    * AND they are the right type.
    * @param data data to check
    * @returns true if data have all required properties of {@link DefData}
    */
    static isDefData(data: any): boolean {
        if (typeof data._did !== 'string') return false
        if (typeof data._lbl !== 'string') return false
        if (typeof data._desc !== 'string') return false
        if (typeof data._emoji !== 'string') return false
        if (!Def.isSingleEmoji(data._emoji)) return false
        if (data._scope == undefined || !Def.isValidScope(data._scope)) return false
        if (typeof data._uid !== 'string') return false
        if (typeof data._created !== 'string') return false
        if (typeof data._deleted !== 'boolean') return false
        if (typeof data._updated !== 'string') return false
        if (!Array.isArray(data._pts)) return false
        if (!Array.isArray(data._tags)) return false
        return true;
    }

    static isValidScope(typeStr: string): boolean {
        const values = Object.values(Scope);
        return values.includes(typeStr as unknown as Scope)
    }

    private static isSingleEmoji(emojiStr: string): boolean {
        return [...new Intl.Segmenter().segment(emojiStr)].length == 1;
    }
}

export class PointDef {
    data: PointDefData
    private _def: Def;
    constructor(newPointDefData: PointDefLike, def: Def) {
        if (newPointDefData._pid === undefined) throw new Error("No PointDef _pid supplied.");
        if (newPointDefData._type !== undefined && !PointDef.isValidType(newPointDefData._type)) throw new Error('Cannot parse point type ' + newPointDefData._type);
        if (newPointDefData._rollup !== undefined && !PointDef.isValidRollup(newPointDefData._rollup)) throw new Error('Cannot parse point rollup ' + newPointDefData._rollup);

        this._def = def;

        this.data = {
            _pid: newPointDefData._pid,
            _lbl: newPointDefData._lbl ?? 'Label unset',
            _type: newPointDefData._type ?? PointType.TEXT,
            _desc: newPointDefData._desc ?? 'Set a description',
            _emoji: newPointDefData._emoji ?? '',
            _rollup: newPointDefData._rollup ?? Rollup.COUNT,
            _hide: newPointDefData._hide ?? false,
            _opts: {}
        }
        if (this.data._lbl == 'Label unset') this.data._lbl = "Label unset for pid " + this.data._pid;
        if (this.shouldHaveOpts() && newPointDefData._opts !== undefined) {
            this.data._opts = PointDef.validateOptsArray(newPointDefData._opts);
        }

        if (!PointDef.isPointDefData(this.data)) throw new Error('Mal-formed PointDef')
    }
    get pid() {
        return this.data._pid;
    }
    get lbl() {
        return this.data._lbl;
    }
    get type() {
        return this.data._type;
    }
    get desc() {
        return this.data._desc;
    }
    get emoji() {
        return this.data._emoji;
    }
    get hide() {
        return this.data._hide
    }
    get opts() {
        return this.data._opts
    }
    get rollup() {
        return this.data._rollup
    }
    public get def(): Def {
        return this._def;
    }

    set lbl(newLbl: string) {
        this.data._lbl = newLbl
        this.def.__modified = true;
    }
    set desc(newDesc: string) {
        this.data._desc = newDesc
        this.def.data._pts.find(dp => dp._pid === this.data._pid)!._desc = newDesc;
        // this.def.getPoint(this.data._pid).data._desc = newDesc;
        this.def.__modified = true;
    }
    set emoji(newEmoji: string) {
        if (!PointDef.isSingleEmoji(newEmoji)) {
            console.warn('Tried to set an emoji with something that was too long, emoji will not change');
            return
        }
        this.data._emoji = newEmoji
        this.def.getPoint(this.data._pid).data._emoji = newEmoji;
        this.def.__modified = true;
    }
    set hide(hideIt: boolean) {
        this.data._hide = hideIt;
        this.def.__modified = true;
    }
    set rollup(newRollup: Rollup) {
        //#TODO - check if rollup is compatible with this.type
        if (PointDef.isValidRollup(newRollup)) this.data._rollup = newRollup;
    }

    toData(): PointDefData {
        return JSON.parse(JSON.stringify(this.data));
    }

    /**
     * 
     * @param oid required - oid of option ot change
     * @param newLbl optional - if supplied option label will be set
     * @returns 
     */
    setOpt(oid: string, newLbl: string) {
        if (!Object.hasOwn(this.opts!, oid)) {
            console.warn('Tried to setOpt with a non-existant oid. If trying to create a new one, use addOpt().');
            return this
        }
        this.opts![oid] = newLbl;
        this.def.__modified = true;
        return this
    }

    /**
     * Passes along the save to the Def that owns this.
     */
    save() {
        this.def.save();
    }

    private static validateOptsArray(optsMap: OptMap) {
        if (typeof optsMap !== 'object') throw new Error('optsMap not an object');
        let keys = Object.keys(optsMap)
        keys.forEach(key => {
            //not modifiying, just looking for errors
            if (
                typeof key !== 'string' ||
                typeof optsMap[key] !== 'string'
            ) throw new Error("Option wasn't formatted like an 'opt'")
        })
        //you *could* create new array of objects explicitly only keeping the 3 desired keys,
        //but you're not.
        return optsMap
    }

    addOpt(lbl: string, oid?: string) {
        if (!this.shouldHaveOpts()) {
            console.warn('Cannot add option to PointDef of type ' + this.type);
            return
        }
        if (oid === undefined) oid = makeSmallID();
        this.opts![oid] = lbl;
        this.def.__modified = true;
        return this;
    }

    removeOpt(lbl?: string, oid?: string): PointDef {
        if (lbl === undefined && oid === undefined) throw new Error("must supply either a label or option ID");
        if (oid === undefined) {
            oid = this.getOptOid(lbl!);
        }
        if (this.opts![oid!] !== undefined) {
            delete this.opts![oid!]
        }
        this.def.__modified = true;
        return this
    }

    getOptLbl(oid: string): string | undefined {
        if (this.opts === undefined) return undefined
        return this.opts![oid];
    }

    getOptOid(lbl: string): string | undefined {
        if (this.opts === undefined) return undefined
        let opt = Object.keys(this.opts!).find(key => this.opts![key] === lbl);
        return opt
    }

    /**
     * The Def that contains this PointDef.
     */
    getDef(): Def {
        return this.def;
    };

    shouldHaveOpts(): boolean {
        return this.type === PointType.SELECT || this.type === PointType.MULTISELECT;
    }

    /**
    * Predicate to check if an object has all {@link PointDefData} properties
    * AND they are the right type.
    * @param data data to check
    * @returns true if data have all required properties of {@link DefData}
    */
    static isPointDefData(data: any): boolean {
        if (typeof data !== 'object') return false;
        if (typeof data._lbl !== 'string') return false
        if (typeof data._desc !== 'string') return false
        if (typeof data._emoji !== 'string') return false
        if (!PointDef.isSingleEmoji(data._emoji)) return false
        if (typeof data._hide !== 'boolean') return false
        if (data._type == undefined || !PointDef.isValidType(data._type)) return false
        if (data._rollup == undefined || !PointDef.isValidRollup(data._rollup)) return false
        return true;
    }

    /**
    * Attempts to intercept poorly-typed values and convert them if possible.
    * If conversion isn't possible, returns undefined and logs to console.warn
    * @param _val value to check
    * @param _type type to attempt to convert to
    * @returns correctly-typed _val, or undefined if _val cannot be converted
    */
    ensureValType(_val: string | number | boolean | object, _type?: PointType) {
        if (_type === undefined) _type = this.type;

        if (_type === PointType.BOOL) {
            if (typeof _val === 'boolean') return _val;
            if (typeof _val === 'string') return _val.toUpperCase() === 'TRUE';
            if (typeof _val === "number") return _val !== 0;
            throw new Error(`Cannot convert this to boolean:` + _val)
        }
        if (_type === PointType.DURATION) {
            if (typeof _val === 'string') return _val;
            //if (typeof _val === "number") return _val !== 0; //number of seconds? millseconds?
            if (typeof _val === 'number') {
                // console.warn('Assuming excel portion of day for duration: ', _val)
                return Temporal.Duration.from({ seconds: Math.round(86400 * _val) }).toString()
            }
            throw new Error(`Cannot convert this to duration:` + _val)
        }
        if (_type === PointType.FILE) {
            if (typeof _val === 'string') return _val;
            throw new Error(`Cannot convert this to file:` + _val)
        }
        if (_type === PointType.MARKDOWN) {
            if (typeof _val === 'boolean') return _val.toString();
            if (typeof _val === 'string') return _val;
            if (typeof _val === "number") return _val.toString();
            throw new Error(`Cannot convert this to markdown:` + _val)
        }
        if (_type === PointType.MULTISELECT) {
            if (Array.isArray(_val)) return _val;
            if (typeof _val === 'string') return _val.split(',').map(text => text.trim());
            throw new Error(`Cannot convert this to multiselect:` + _val)
        }
        if (_type === PointType.NUMBER) {
            if (typeof _val === 'boolean') return _val ? 1 : 0;
            if (typeof _val === 'string') return Number.parseInt(_val);
            if (typeof _val === "number") return _val;
            throw new Error(`Cannot convert this to number:` + _val)
        }
        if (_type === PointType.PHOTO) {
            if (typeof _val === 'string') return _val;
            throw new Error(`Cannot convert this to PHOTO:` + _val)
        }
        if (_type === PointType.SELECT) {
            if (typeof _val === 'string') return _val;
            if (Array.isArray(_val)) return _val.join('|||')
            if (_val === undefined) return []; //I guess
            throw new Error(`Cannot convert this to select:` + _val);
        }
        if (_type === PointType.TEXT) {
            if (typeof _val === 'boolean') return _val.toString();
            if (typeof _val === 'string') return _val.trim();
            if (typeof _val === "number") return _val.toString();
            if (_val === undefined) return ''; //I guess
            return _val.toString();
        }
        if (_type === PointType.TIME) {
            if (typeof _val === 'string') return _val.trim();
            if (typeof _val === "number" && _val >= 0 && _val <= 1) {
                //attempt to support "proportion of day to time" like Excel would
                return new Temporal.PlainTime(0, 0).add({ seconds: Math.round(86400 * _val) }).toString();
            }
            throw new Error(`Cannot convert this to time:` + _val)
        }
        if (_type === PointType.JSON) {
            if (typeof _val === 'string') return _val.trim();
            if (typeof _val === "object") return JSON.stringify(_val);
            throw new Error(`Cannot convert this to JSON:` + _val)
        }
        throw new Error("Type not supported: " + _type);
    }

    static isValidType(typeStr: string): boolean {
        //Handy bit of Enum functionality here for ref
        const values = Object.values(PointType);
        return values.includes(typeStr as unknown as PointType)
    }

    static isValidRollup(typeStr: string): boolean {
        //Handy bit of Enum functionality here for ref
        const values = Object.values(Rollup);
        return values.includes(typeStr as unknown as Rollup)
    }

    private static isSingleEmoji(emojiStr: string): boolean {
        return [...new Intl.Segmenter().segment(emojiStr)].length == 1;
    }
}

export class Entry extends Element {
    declare data: EntryData
    private _def: Def;
    private _period: Period;
    constructor(entryData: EntryLike, def?: Def) {
        super(entryData);
        if (def !== undefined) {
            this._def = def;
        } else {
            this._def = PDW.getInstance().getFromManifest(entryData._did!)
        }

        //forcing scope adherance
        if (entryData._period !== undefined) {
            this._period = new Period(entryData._period, this.def.scope);
        } else {
            this._period = Period.nowAsPeriod(this.def.scope);
        }

        this.data = {
            ...this.data,
            _did: this.def.did,
            _period: this.period.toString(),
            _eid: entryData._eid ?? makeUID(),
            _note: entryData._note ?? '',
            _source: entryData._source ?? ''
        }

        //spawn new EntryPoints for any non-underscore-prefixed keys
        let pids = Object.keys(entryData).filter(key => key.substring(0, 1) !== '_');
        pids.forEach(pid => {
            const keyval = this.sanitizePointData({ [pid]: entryData[pid] });
            this.data[keyval.pid] = keyval.val;
        })

        if (!Entry.isEntryData(this.data)) throw new Error('The Entry was mal-formed');
    }

    get did() {
        return this.data._did;
    }
    get eid() {
        return this.data._eid;
    }
    public get period(): Period {
        return this._period;
    }
    get note() {
        return this.data._note;
    }
    get source() {
        return this.data._source;
    }
    public get def() {
        return this._def;
    }

    set note(newNote: string) {
        this.data._note = newNote;
        this.__modified = true;
    }
    set source(newSource: string) {
        this.data._source = newSource;
        this.__modified = true;
    }
    public set period(value: Period | string) {
        if (typeof value === 'string') value = new Period(value);
        //ensure scope agreement
        value = value.zoomTo(this.def.scope)
        this.data._period = value.toString();
        this._period = value;
        this.__modified = true;
    }

    /**
     * Looks up the associated PointDef based on the object key.
     * Checks the value against that PointDef._type. Calls {@link PointDef.ensureValType()}
     * @param rawPointData key: value pair with key = _pid or _lbl of PointDef
     * @returns an object with 'key' = _pid for PointDef, and 'val' = value
     */
    sanitizePointData(rawPointData: any): { 'pid': string, 'lbl': string, 'val': any, 'pointDef': PointDef } {
        if (typeof rawPointData !== 'object') throw new Error('Saw non-object Entry Point:' + rawPointData);
        if (Object.keys(rawPointData).length > 1) throw new Error('Expected a single-keyed object. Saw multiple keys');
        const key = Object.keys(rawPointData)[0];

        const assPointDef = this.def?.getPoint(key);
        if (assPointDef === undefined) throw new Error('No PointDef found for ' + key)
        const validatedValue = assPointDef?.ensureValType(rawPointData[key]);

        return {
            'pid': assPointDef.pid,
            'lbl': assPointDef.lbl,
            'val': validatedValue,
            'pointDef': assPointDef
        }
    }

    getPoints(): { 'pid': string, 'lbl': string, 'val': any, 'pointDef': PointDef }[] {
        let pids = Object.keys(this.data).filter(key => key.substring(0, 1) !== '_');
        return pids.map(pid => {
            const assPD = this.def.pts.find(point => point.pid === pid);
            return {
                pointDef: assPD!,
                pid: pid,
                lbl: assPD!.lbl,
                val: this.data[pid]
            }
        })
    }

    getPoint(pidOrLbl: string): { 'pid': string, 'lbl': string, 'val': any, 'pointDef': PointDef } | undefined {
        const allPoints = this.getPoints();
        let point = allPoints.find(point => point.pid === pidOrLbl);
        if (point !== undefined) return point;
        return allPoints.find(point => point.lbl === pidOrLbl);
    }

    getPointVal(pidOrLbl: string): any {
        return this.getPoint(pidOrLbl)!.val;
    }

    setPointVals(pidValArr: { [pid: string]: any }[]): Entry {
        pidValArr.forEach(keyVal => {
            let pointVal = this.sanitizePointData(keyVal);
            this.data[pointVal.pid] = pointVal.val;
        })
        this.__modified = true;
        return this;
    }

    setPointVal(pid: string, val: any): Entry {
        this.__modified = true;
        return this.setPointVals([{ [pid]: val }]);
    }

    /**
    * Predicate to check if an object has all {@link EntryData} properties
    * AND they are the right type. Does not check for EntryPoints or their types.
    * @param data data to check
    * @returns true if data have all required properties of {@link DefData}
    */
    static isEntryData(data: any): boolean {
        if (typeof data._did !== 'string') return false
        if (typeof data._eid !== 'string') return false
        if (typeof data._note !== 'string') return false
        if (typeof data._period !== 'string') return false
        if (typeof data._uid !== 'string') return false
        if (typeof data._created !== 'string') return false
        if (typeof data._deleted !== 'boolean') return false
        if (typeof data._updated !== 'string') return false
        if (typeof data._source !== 'string') return false
        return true;
    }
}

/**
 * Periods are Immutable. All methods return new copies of Period.
 * They are basically wrappers around a string.
 */
export class Period {
    /**
     * The Period itself, represented in a {@link PeriodStr} format.  
     * 
     * **Examples**:
     * - '2020'
     * - '2020-Q1'
     * - '2020-03'
     * - '2020-03-19'
     * - '2020-03-19T18'
     * - '2020-03-19T18:59'
     * - '2020-03-19T18:59:25'
     */
    periodStr: PeriodStr;
    scope: Scope;
    private _zoomLevel: number

    constructor(periodStr: PeriodStr | Period, desiredScope?: Scope) {
        if (typeof periodStr !== 'string') periodStr = periodStr.periodStr;
        this.periodStr = periodStr;
        this.scope = Period.inferScope(periodStr);
        if (this.scope === Scope.SECOND && this.periodStr.length > 20) this.periodStr = convertFullISOToPlainDateStr(this.periodStr);
        this._zoomLevel = Period.zoomLevel(this.scope)

        if (desiredScope !== undefined && this.scope !== desiredScope) {
            console.log('Converting ' + periodStr + ' to scope ' + desiredScope);
            return this.zoomTo(desiredScope);
        }

        /**
         * This sucked to figure out and was annoying to need to do at all.
         * @param isoString an ISO formatting string, along with the timezone offset
         * @returns an ISO formatted string without the offset, representing the time *in that timezone*
         */
        function convertFullISOToPlainDateStr(isoString: string): string {
            let temp = Temporal.PlainDateTime.from(isoString);
            const tzString = Temporal.TimeZone.from(isoString).toString();
            const offsetString = tzString.substring(0,1) + 'PT' + Number.parseInt(tzString.substring(1,3)) + 'h' + + Number.parseInt(tzString.substring(5,7)) + 'm';
            console.log(offsetString);
            temp = temp.add(offsetString);
            let str = temp.toJSON()
            return str
        }
    }

    private static zoomLevel(scope: Scope): number {
        return [
            Scope.SECOND,
            Scope.MINUTE,
            Scope.HOUR,
            Scope.DAY,
            Scope.WEEK,
            Scope.MONTH,
            Scope.QUARTER,
            Scope.YEAR
        ].findIndex(val => val === scope)
    }

    /**
     * Yay overriding default Object prototype methods!
     * @returns periodStr
     */
    toString() {
        return this.periodStr;
    }

    toTemporalPlainDate() {
        return Temporal.PlainDate.from(this.periodStr);
    }

    toTemporalPlainDateTime() {
        return Temporal.PlainDateTime.from(this.periodStr);
    }

    getEnd(): Period {
        if (this.scope === Scope.SECOND) return new Period(this.periodStr);
        if (this.scope === Scope.MINUTE) return new Period(this.periodStr + ':59');
        if (this.scope === Scope.HOUR) return new Period(this.periodStr + ':59:59');
        if (this.scope === Scope.DAY) return new Period(this.periodStr + 'T23:59:59');

        if (this.scope === Scope.WEEK) {
            let numWks = Number.parseInt(this.periodStr.split('W')[1]) - 1;
            //some years dont' start until after the 1st
            if (Period.needsWeekShift(this.periodStr.substring(0, 4))) numWks = numWks + 1
            let init = Temporal.PlainDate.from(this.periodStr.split('-')[0] + '01-01')

            let sun = init.add({ days: 7 - init.dayOfWeek })
            sun = sun.add({ days: numWks * 7 });
            return new Period(sun.toString() + 'T23:59:59')

        }
        if (this.scope === Scope.MONTH) {
            let lastDay = Temporal.PlainDate.from(this.periodStr + '-01').daysInMonth;
            return new Period(this.periodStr + '-' + lastDay.toString() + 'T23:59:59')
        }
        if (this.scope === Scope.QUARTER) {
            const year = this.periodStr.substring(0, 4)
            const q = Number.parseInt(this.periodStr.slice(-1));
            const month = q * 3
            const d = Temporal.PlainDate.from(year + '-' + month.toString().padStart(2, '0') + '-01').daysInMonth;
            return new Period(year + '-' + month.toString().padStart(2, '0') + '-' + d + 'T23:59:59');
        }
        return new Period(this.periodStr + "-12-31T23:59:59")
    }

    /**
     * 
     * @returns the first second of the period (e.g. 2020-01-01T00:00:00)
     */
    getStart(): Period {
        if (this._zoomLevel === 0) return new Period(this);
        if (this.scope === Scope.YEAR) return new Period(this.toString() + '-01-01T00:00:00')
        if (this.scope === Scope.QUARTER) return new Period(this.zoomIn() + '-01T00:00:00')
        if (this.scope === Scope.MONTH) return new Period(this.toString() + '-01T00:00:00')
        //above preempts week, cause it's not purely hierarchical,
        //from here you can just "zoomIn" to the beginning of the period
        let per = this.zoomIn();
        while (per._zoomLevel !== 0) {
            per = per.zoomIn()
        }
        return per;
    }

    /**
     * 
     */
    zoomTo(desiredScope: Scope): Period {
        const desiredLevel = Period.zoomLevel(desiredScope);
        if (this._zoomLevel === desiredLevel) return new Period(this);
        if (this._zoomLevel < desiredLevel) {
            let zoomOut = this.zoomOut()
            while (zoomOut._zoomLevel < desiredLevel) {
                //need to bypass weeks
                if (desiredLevel !== 4 && zoomOut._zoomLevel === 3) {
                    zoomOut = new Period(zoomOut.periodStr.substring(0, 7))
                } else {
                    zoomOut = zoomOut.zoomOut()
                }
            }
            return zoomOut;
        }
        let zoomIn = this.zoomIn()
        while (zoomIn._zoomLevel > desiredLevel) {
            if (desiredLevel !== 4 && zoomIn._zoomLevel === 5) {
                zoomIn = new Period(zoomIn.periodStr + '-01')
            } else {
                zoomIn = zoomIn.zoomIn()
            }
        }
        return zoomIn;
    }

    /**
     * Zooms in on the BEGINNING (?) of the Period
     * @returns the next level finer-grain scope at the beginning of this scope
     */
    zoomIn(): Period {
        if (this.scope === Scope.YEAR) return new Period(this.periodStr + '-Q1');
        if (this.scope === Scope.QUARTER) {
            const year = this.periodStr.substring(0, 4);
            const month = Number.parseInt(this.periodStr.slice(-1)) * 3 - 2
            return new Period(year + '-' + month.toString().padStart(2, '0'));
        }
        if (this.scope === Scope.MONTH) {
            const temp = Temporal.PlainDate.from(this.periodStr + "-01")
            let year = temp.year;
            if (temp.weekOfYear > 50 && temp.dayOfYear < 14) year = year - 1;
            if (temp.weekOfYear == 1 && temp.dayOfYear > 360) year = year + 1
            const weekNum = temp.weekOfYear
            return new Period(year + "-W" + weekNum.toString().padStart(2, '0'));
        }
        if (this.scope === Scope.WEEK) {
            let numWks = Number.parseInt(this.periodStr.split('W')[1]) - 1;
            //if the previous year had 53 weeks, this is necessary
            if (Period.needsWeekShift(this.periodStr.substring(0, 4))) numWks = numWks + 1
            let init = Temporal.PlainDate.from(this.periodStr.split('-')[0] + '01-01')
            let mon = init.add({ days: 1 - init.dayOfWeek }).add({ days: numWks * 7 })
            return new Period(mon.toString());
        }
        if (this.scope === Scope.DAY) return new Period(this.periodStr + "T00")
        if (this.scope === Scope.HOUR) return new Period(this.periodStr + ":00")
        if (this.scope === Scope.MINUTE) return new Period(this.periodStr + ":00")
        //zooming in from a second returns itself
        return new Period(this.periodStr)
    }

    zoomOut(): Period {
        if (this.scope === Scope.SECOND) return new Period(this.periodStr.slice(0, -3));
        if (this.scope === Scope.MINUTE) return new Period(this.periodStr.slice(0, -3));
        if (this.scope === Scope.HOUR) return new Period(this.periodStr.slice(0, -3));
        if (this.scope === Scope.DAY) {
            //this SHOULD be usign Temporal.PlaidDateTime.weekOfYear(), but that's not implemented on this polyfill
            const temp = Temporal.PlainDateTime.from(this.periodStr);
            //catching edge cases like 2019-12-31 => 2020-W01 & 2023-01-01 => 2022-W52
            let year = temp.year;
            if (temp.weekOfYear > 50 && temp.dayOfYear < 14) year = year - 1;
            if (temp.weekOfYear == 1 && temp.dayOfYear > 360) year = year + 1
            return new Period(year + "-W" + temp.weekOfYear.toString().padStart(2, '0'));
        }
        if (this.scope === Scope.WEEK) {
            return new Period(Period.getMidWeek(this).toString().substring(0, 7))
            // //weeks zooming out resolve to whichever month contains the THURSDAY of the week
            // let numWks = Number.parseInt(this.periodStr.split('W')[1]) - 1;
            // //if the previous year had 53 weeks, this is necessary
            // if (Period.prevYearHas53Weeks(this.periodStr.substring(0, 4))) numWks = numWks + 1
            // let init = Temporal.PlainDate.from(this.periodStr.split('-')[0] + '01-01')
            // let thur = init.add({ days: 4 - init.dayOfWeek }).add({ days: numWks * 7 })
            // return new Period(thur.toPlainYearMonth().toString());
        }
        if (this.scope === Scope.MONTH) {
            let yearStr = this.periodStr.split('-')[0];
            let month = Number.parseInt(this.periodStr.split('-')[1]);
            let quarterStr = Math.ceil(month / 3).toString();
            return new Period(yearStr + '-Q' + quarterStr);
        }
        // else is a Scope.QUARTER or Scope.YEAR, I think I'm goign to let Scope.YEAR return itself
        return new Period(this.periodStr.substring(0, 4))
    }

    addDuration(temporalDurationStr: string): Period {
        const startTemp = Temporal.PlainDateTime.from(this.getStart().periodStr);
        const endTemp = startTemp.add(temporalDurationStr);
        return new Period(endTemp.toString()).zoomTo(this.scope);
    }

    contains(period: Period | PeriodStr): boolean {
        if (typeof period === 'string') period = new Period(period);
        //converting week scopes to THURSDAY of that week
        if (period.scope === Scope.WEEK) period = Period.getMidWeek(period)
        const inBegin = Temporal.PlainDateTime.from(period.getStart().periodStr)
        const inEnd = Temporal.PlainDateTime.from(period.getEnd().periodStr)
        const thisBegin = Temporal.PlainDateTime.from(this.getStart().periodStr);
        const thisEnd = Temporal.PlainDateTime.from(this.getEnd().periodStr);
        const start = Temporal.PlainDateTime.compare(inBegin, thisBegin);
        const end = Temporal.PlainDateTime.compare(thisEnd, inEnd);
        return start !== -1 && end !== -1
    }

    isBefore(period: Period): boolean {
        const start = Temporal.PlainDateTime.from(this.getEnd().periodStr);
        const end = Temporal.PlainDateTime.from(period.getStart().periodStr);
        return Temporal.PlainDateTime.compare(start, end) === -1
    }

    isAfter(period: Period): boolean {
        const start = Temporal.PlainDateTime.from(this.getStart().periodStr);
        const end = Temporal.PlainDateTime.from(period.getEnd().periodStr);
        return Temporal.PlainDateTime.compare(start, end) === 1
    }

    // I can't believe I was able to reduce these to a 1 liner
    getNext(): Period {
        // let start = this.getStart();
        // let end = this.getEnd();
        // let plusOne = end.addDuration('PT1S');
        // let zoomed = plusOne.zoomTo(this.scope);
        return this.getEnd().addDuration('PT1S').zoomTo(this.scope);

    }
    getPrev(): Period {
        return this.getStart().addDuration('-PT1S').zoomTo(this.scope);
    }

    private static needsWeekShift(yearStr: string): boolean {
        return Temporal.PlainDate.from(yearStr + '-01-01').dayOfWeek > 4;

    }

    private static getMidWeek(period: Period) {
        if (period.scope !== Scope.WEEK) return period;
        return period.getStart().zoomTo(Scope.DAY).addDuration('P3D');
    }

    static allPeriodsIn(start: Period, end: Period, scope: Scope, asStrings = false): Period[] | string[] {
        if (Temporal.PlainDateTime.compare(Temporal.PlainDateTime.from(start.getStart().periodStr), Temporal.PlainDateTime.from(end.getStart().periodStr)) === 1) {
            console.warn('You may have flipped your start and end dates accidentally... or something')
            const temp = start;
            start = end;
            end = temp;
        }
        // const startOfStart = start.getStart().periodStr;
        // const endOfEnd = end.getEnd().periodStr;
        let first, last, list: any[];
        first = start.zoomTo(scope);
        last = end.getNext().zoomTo(Scope.SECOND).addDuration('-PT1S').zoomTo(scope);

        let member = first;
        list = [];
        if (asStrings) {
            do {
                // list.push({[member.periodStr]: {from: member.getStart().toString(), to: member.getEnd().toString()}});
                list.push(member.periodStr);
                member = member.getNext();
            } while (member.periodStr <= last.periodStr)
            return list as string[]
        } else {
            do {
                list.push(member);
                member = member.getNext();

            } while (member.periodStr <= last.periodStr)
            return list as Period[]
        }
    }

    //getEntriesInPeriodMatchingFilter(params: StandardFilters): Element[]

    static now(scope: Scope): PeriodStr {
        let seedStr = '';
        let nowTemp = Temporal.Now.zonedDateTimeISO();
        if (scope === Scope.YEAR) seedStr = nowTemp.year.toString();
        if (scope === Scope.QUARTER) seedStr = nowTemp.year.toString() + '-Q' + Math.ceil(nowTemp.month / 3);
        if (scope === Scope.MONTH) seedStr = nowTemp.toPlainYearMonth().toString()
        if (scope === Scope.WEEK) seedStr = nowTemp.year.toString() + '-W' + nowTemp.weekOfYear.toString();
        if (scope === Scope.DAY) seedStr = nowTemp.toPlainDate().toString()
        if (scope === Scope.HOUR) seedStr = nowTemp.toString().substring(0, 13)
        if (scope === Scope.MINUTE) seedStr = nowTemp.toString().substring(0, 16)
        if (scope === Scope.SECOND) seedStr = nowTemp.toString().substring(0, 19)
        return seedStr
    }

    static nowAsPeriod(scope: Scope): Period {
        return new Period(Period.now(scope));
    }

    static inferScope(ISOString: string): Scope {
        // /https://xkcd.com/208/
        if (/\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d/i.test(ISOString))
            return Scope.SECOND;
        if (/\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d/i.test(ISOString))
            return Scope.MINUTE;
        if (/\d{4}-[01]\d-[0-3]\dT[0-2]\d/i.test(ISOString))
            return Scope.HOUR;
        if (/^([12]\d{3}-(0[1-9]|1[0-2])-(0[1-9]|[12]\d|3[01]))$/.test(ISOString))
            return Scope.DAY;
        if (/^([0-9]{4})-?W(5[0-3]|[1-4][0-9]|0[1-9])$/i.test(ISOString))
            return Scope.WEEK;
        if (/^([0-9]{4})-(1[0-2]|0[1-9])$/.test(ISOString))
            return Scope.MONTH;
        if (/^[0-9]{4}-Q[1-4]$/i.test(ISOString))
            return Scope.QUARTER;
        if (/^([0-9]{4})$/.test(ISOString))
            return Scope.YEAR;
        throw new Error('Attempted to infer scope failed for: ' + ISOString);
    }
}

//#TODO - clean up some query methods, maybe combine things like "dids" "defs" "defsLbld"
export class Query {
    // private verbosity: 'terse' | 'normal' | 'verbose'
    // private rollup: boolean
    private params: StandardParams
    private sortOrder: undefined | 'asc' | 'dsc'
    private sortBy: undefined | string
    constructor(paramsIn?: StandardParams) {
        // this.verbosity = 'normal';
        // this.rollup = false;
        this.params = { includeDeleted: 'no' }; //default
        if (paramsIn !== undefined) this.parseParamsObject(paramsIn)
    }

    parseParamsObject(paramsIn: StandardParams) {
        if (paramsIn?.includeDeleted !== undefined) {
            if (paramsIn.includeDeleted === 'no') this.includeDeleted(false);
            if (paramsIn.includeDeleted === 'yes') this.includeDeleted(true);
            if (paramsIn.includeDeleted === 'only') this.onlyIncludeDeleted();
        }
        if (paramsIn?.allOnPurpose !== undefined) this.allOnPurpose(paramsIn.allOnPurpose);
        if (paramsIn?.createdAfter !== undefined) this.createdAfter(paramsIn.createdAfter);
        if (paramsIn?.createdBefore !== undefined) this.createdBefore(paramsIn.createdBefore);
        if (paramsIn?.updatedAfter !== undefined) this.updatedAfter(paramsIn.updatedAfter);
        if (paramsIn?.updatedBefore !== undefined) this.updatedBefore(paramsIn.updatedBefore);
        if (paramsIn?.defLbl !== undefined) this.forDefsLbld(paramsIn.defLbl);
        if (paramsIn?.did !== undefined) this.forDids(paramsIn.did);
        if (paramsIn?.uid !== undefined) this.uids(paramsIn.uid);
        if (paramsIn?.eid !== undefined) this.eids(paramsIn.eid);
        if (paramsIn?.tag !== undefined) this.tags(paramsIn.tag);
        if (paramsIn?.from !== undefined) this.from(paramsIn.from);
        if (paramsIn?.to !== undefined) this.to(paramsIn.to);
        if (paramsIn?.inPeriod !== undefined) this.inPeriod(paramsIn.inPeriod);
        if (paramsIn?.scope !== undefined) this.scope(paramsIn.scope);
        if (paramsIn?.today !== undefined) this.inPeriod(Period.now(Scope.DAY));
        if (paramsIn?.thisWeek !== undefined) this.inPeriod(Period.now(Scope.WEEK));
        if (paramsIn?.thisMonth !== undefined) this.inPeriod(Period.now(Scope.MINUTE));
        if (paramsIn?.thisQuarter !== undefined) this.inPeriod(Period.now(Scope.QUARTER));
        if (paramsIn?.thisYear !== undefined) this.inPeriod(Period.now(Scope.YEAR));
        return this
    }

    static parseFromURL(url: string): Query {
        console.log(url);

        throw new Error('unimplemented')

    }

    encodeAsURL(): string {
        //new URLSearchParams(obj).toString(); //ref code
        throw new Error('unimplemented')
    }

    includeDeleted(b = true) {
        if (b) {
            this.params.includeDeleted = 'yes';
        } else {
            this.params.includeDeleted = 'no';
        }
        return this
    }

    onlyIncludeDeleted() {
        this.params.includeDeleted = 'only';
        return this
    }

    forDids(didList: string[] | string) {
        if (!Array.isArray(didList)) didList = [didList];
        this.params.did = didList;
        return this
    }

    forDefsLbld(defLbls: string[] | string) {
        if (!Array.isArray(defLbls)) defLbls = [defLbls];
        this.params.defLbl = defLbls;
        return this
    }

    createdAfter(epochDateOrTemporal: EpochStr | Date | Temporal.ZonedDateTime) {
        const epoch = makeEpochStrFrom(epochDateOrTemporal);
        this.params.createdAfter = epoch;
        return this;
    }

    createdBefore(epochDateOrTemporal: EpochStr | Date | Temporal.ZonedDateTime) {
        const epoch = makeEpochStrFrom(epochDateOrTemporal);
        this.params.createdBefore = epoch;
        return this;
    }

    updatedAfter(epochDateOrTemporal: EpochStr | Date | Temporal.ZonedDateTime) {
        const epoch = makeEpochStrFrom(epochDateOrTemporal);
        this.params.updatedAfter = epoch;
        return this;
    }

    updatedBefore(epochDateOrTemporal: EpochStr | Date | Temporal.ZonedDateTime) {
        const epoch = makeEpochStrFrom(epochDateOrTemporal);
        this.params.updatedBefore = epoch;
        return this;
    }

    forDefs(defList: Def[] | Def) {
        if (!Array.isArray(defList)) defList = [defList];
        return this.forDids(defList.map(def => def.did));
    }

    uids(uid: string[] | string) {
        if (!Array.isArray(uid)) uid = [uid];
        this.params.uid = uid;
        return this
    }

    eids(eid: string[] | string) {
        if (!Array.isArray(eid)) eid = [eid];
        this.params.eid = eid;
        return this
    }

    rollup(to: Scope){
        to = to.toUpperCase() as Scope;
        this.params.rollup = to;
        return this
    }

    /**
     * Cannot be used in conjuction with dids. This sets `params.did` internally.
     * @param tid tag ID of tags to be used
     * @returns 
     */
    tags(tags: string[] | string) {
        if (!Array.isArray(tags)) tags = [tags];
        //convert tags into dids
        const manifest = PDW.getManifest();
        const dids = manifest.filter(def => def.hasTag(tags))
        this.params.did = dids.map(d => d.data._did);
        return this
    }

    scope(scopes: Scope[] | Scope): Query {
        if (!Array.isArray(scopes)) scopes = [scopes];
        let defs = PDW.getInstance().manifest.filter(def => (<Scope[]>scopes).some(scope => scope === def.scope));
        this.params.did = defs.map(def => def.did);
        return this
    }

    scopeMin(scope: Scope): Query {
        let scopes = Object.values(Scope);
        let index = scopes.indexOf(scope);
        return this.scope(scopes.slice(index));
    }

    scopeMax(scope: Scope): Query {
        let scopes = Object.values(Scope);
        let index = scopes.indexOf(scope);
        return this.scope(scopes.slice(0, index + 1));
    }

    allOnPurpose(allIn = true): Query {
        this.params.allOnPurpose = allIn;
        return this
    }

    from(period: Period | PeriodStr) {
        this.params.from = period;
        return this
    }

    to(period: Period | PeriodStr) {
        this.params.to = period;
        return this
    }

    inPeriod(period: Period | PeriodStr) {
        this.params.from = period;
        this.params.to = period;
        return this
    }

    /**
     * How to sort the entries in the result.
     * @param propName underscore-prefixed known prop, or the pid of the Point to sort by
     * @param type defaults to 'asc'
     */
    sort(propName: string, type: undefined | 'asc' | 'dsc') {
        if (type === undefined) type = 'asc';
        this.sortOrder = type;
        this.sortBy = propName;
    }

    async run(): Promise<QueryResponse> {
        //empty queries are not allowed
        if (this.params === undefined ||
            (!this.params.allOnPurpose && Object.keys(this.params).length <= 1)
        ) {
            return {
                success: false,
                count: 0,
                params: {
                    paramsIn: this.params,
                    asParsed: PDW.sanitizeParams(this.params)
                },
                msgs: ['Empty queries not allowed. If seeking all, include {allOnPurpose: true}'],
                entries: []
            }
        }
        let entries = await PDW.getInstance().getEntries(this.params);
        if (this.sortBy !== undefined) entries = this.applySort(entries);
        let resp: QueryResponse = {
            success: true,
            count: entries.length,
            params: {
                paramsIn: this.params,
                asParsed: PDW.sanitizeParams(this.params)
            },
            entries: entries,
            summary: this.params.hasOwnProperty('rollup') ? PDW.summarize(entries, this.params.rollup as Scope) : undefined
        }
        return resp
    }

    private applySort(entries: Entry[]): Entry[] {
        return entries.sort((a, b) => {
            if (this.sortOrder === 'asc') {
                //@ts-expect-error
                return a[this.sortBy] > b[this.sortBy] ? 1 : -1
            }
            //@ts-expect-error
            return a[this.sortBy] > b[this.sortBy] ? -1 : 1
        })
    }
}

export class DefaultDataStore implements DataStore {
    serviceName: string;
    pdw: PDW;
    defs: Def[];
    entries: Entry[];

    constructor(pdwRef: PDW) {
        this.serviceName = 'In memory dataset';
        this.pdw = pdwRef;
        this.defs = [];
        this.entries = [];
    }

    async commit(trans: Transaction): Promise<CommitResponse> {
        let returnObj: CommitResponse = {
            success: false
        }
        // try {
        //creating new Elements
        trans.create.defs.forEach(newDef => {
            this.defs.push(newDef);
        })
        trans.create.entries.forEach(newEntry => {
            this.entries.push(newEntry);
        })
        returnObj.msgs?.push(`Added:
            ${trans.create.defs.length} Defs, 
            ${trans.create.entries.length} Entries`)

        //updating existing
        //is there a race condition here possibly?
        //NO IDEA WHAT'S GOING ON HERE - if I "await", this is causing tests to fail, it skips the "deletions" section
        this.setElementsInRepo(trans.update.defs.map(d => d.data) as DefData[], this.defs);
        this.setElementsInRepo(trans.update.entries.map(d => d.data) as EntryData[], this.entries);

        //deletions
        trans.delete.defs.forEach(def => {
            let matched = this.defs.find(defInRepo => defInRepo.uid === def.uid);
            if (matched !== undefined) {
                matched.updated = def.updated;
                matched.deleted = def.deleted;
            }
        })
        trans.delete.entries.forEach(entry => {
            let matched = this.entries.find(entryInRepo => entryInRepo.uid === entry.uid);
            if (matched !== undefined) {
                matched.updated = entry.updated;
                matched.deleted = entry.deleted;
            }
        })

        returnObj.success = true;
        // } catch (e) {
        //     console.log(e);
        //     returnObj.msgs = ['An error occurred when querying the DefaultDataStore']
        // }
        return returnObj;
    }

    /**
     * Reset all the arrays to nil.
     * Right now only used for **testing**
     */
    clearAllStoreArrays() {
        this.defs = [];
        this.entries = [];
    }

    async getEntries(params: ReducedParams): Promise<ReducedQueryResponse> {
        let returnObj: ReducedQueryResponse = {
            success: false,
            entries: [],
            msgs: []
        }
        try {
            returnObj.entries = this.getEntriesFromRepo(params);
            returnObj.success = true;
        } catch (e) {
            console.error(e);
            returnObj.msgs = ['An error occurred when querying the DefaultDataStore']
        }
        //force any future updates to *not* change the elements in stores until they're saved explicitly
        returnObj = JSON.parse(JSON.stringify(returnObj));
        return returnObj
    }

    async getDefs(includedDeleted = false): Promise<DefData[]> {
        let params: ReducedParams = { includeDeleted: 'no' };
        if (includedDeleted) params.includeDeleted = 'yes';
        const allMatches = this.defs.filter(def => def.passesFilters(params));
        let noDupes = new Set(allMatches);
        return Array.from(noDupes).map(def => def.toData() as DefData)
    }

    /**
     * For pulling entries that you know the eid of
     * @param eids
     * @param includeDeleted
     * @returns an array of all entries matching the criteria
     */
    private getEntriesFromRepo(params: ReducedParams): EntryData[] {
        const allMatches = this.entries.filter(entry => entry.passesFilters(params));
        let noDupes = new Set(allMatches);
        return Array.from(noDupes).map(entry => entry.toData() as EntryData);
    }

    /**
     * This function is a bit strange, but was extracted from
     * the 6 functions below, which were duplicates code-wise
     * @param elementsIn list of Elements (Defs, Entries, etc) to set
     * @param elementRepo the existing set of Elements in the DataStore (this.defs, this.entries, etc)
     */
    async setElementsInRepo(elementsIn: ElementData[], elementRepo: Element[]): Promise<void> {
        if (elementsIn.length === 0) return;
        let newElements: ElementData[] = [];
        elementsIn.forEach(el => {
            //if we're *only* deleting or undeleting, this should find match.
            let sameUid = elementRepo.find(existingElement => existingElement.uid == el._uid);
            if (sameUid !== undefined) {
                //only replace if the setDefs def is newer, necessary for StorageConnector merges
                if (sameUid.isOlderThan(el)) {
                    sameUid.deleted = el._deleted;
                    sameUid.updated = el._updated;
                }
                return
            }

            //if we're *updating* then we need to find based on the same element ID
            let sameId = elementRepo.find(existingElement => existingElement.data._deleted === false && existingElement.sameIdAs(el));
            if (sameId !== undefined) {
                //only replace if the setDefs def is newer, necessary for StorageConnector merges
                if (sameId.isOlderThan(el)) {
                    sameId.deleted = true;
                    sameId.updated = makeEpochStr();
                    newElements.push(el);
                }
            } else {
                newElements.push(el);
            }
        });
        const type = getElementType(elementsIn[0])
        if (type === 'DefData') elementRepo.push(...newElements.map(d => new Def(d)));
        if (type === 'EntryData') elementRepo.push(...await PDW.inflateEntriesFromData(newElements as EntryData[]));
        // return elementsIn;
    }

    async setDefs(defsIn: Def[]): Promise<DefData[]> {
        return this.setElementsInRepo(defsIn.map(d => d.data) as DefData[], this.defs) as unknown as DefData[];
    }

    async setEntries(entriesIn: Entry[]): Promise<EntryData[]> {
        return this.setElementsInRepo(entriesIn.map(e => e.data), this.entries) as unknown as EntryData[];
    }

    async getOverview(): Promise<DataStoreOverview> {
        throw new Error("Method not implemented.");
    }

    // setAll(completeData: CompleteDataset): CompleteDataset {
    //     throw new Error("Method not implemented.");
    // }

    async connect(pdwRef: PDW): Promise<boolean> {
        this.pdw = pdwRef;
        console.log("Connected to the DefaultDataStore");
        return true

    }

}

//#endregion

//#region ### UTILITIES ###

//TODO - do you want a utils class?

/**
 * Makes a unique identifier for use with _uid and _eid
 */
export function makeUID(): UID {
    return makeEpochStr() + "-" + makeSmallID();
}

export function makeEpochStr(): EpochStr {
    return Temporal.Now.zonedDateTimeISO().epochMilliseconds.toString(36)
}

export function makeSmallID(length = 4): SmallID {
    return Math.random().toString(36).slice(13 - length).padStart(length, "0")
}

export function parseTemporalFromUid(uid: UID): Temporal.ZonedDateTime {
    return parseTemporalFromEpochStr(uid.split("-")[0]);
}

export function isValidEpochStr(epochStr: string): boolean {
    if (typeof epochStr !== 'string') return false;
    if (epochStr.length !== 8) return false; //not supporting way in the past or future
    // technically creates a 2059 problem... but that's my problem when I'm 2x as old as I am now
    //console.log(parseTemporalFromEpochStr('zzzzzzz').toLocaleString()) //is "6/25/1972, 6:49:24 PM CDT"
    //console.log(parseTemporalFromEpochStr('100000000').toLocaleString()) //is "5/25/2059, 12:38:27PM CDT"
    //for now this is good enough. I could parse a temporal out then check if it succeed & is in a resonable year, but meh
    return true
}

export function makeEpochStrFrom(epochDateOrTemporal: EpochStr | Date | Temporal.ZonedDateTime): EpochStr | undefined {
    if (typeof epochDateOrTemporal === 'string') {
        if (isValidEpochStr(epochDateOrTemporal)) return epochDateOrTemporal;
        //This WILL cause errors given bad strings, but I want to support lazy strings like "2023-07-28"
        return Temporal.Instant.fromEpochMilliseconds(new Date(epochDateOrTemporal).getTime()).toZonedDateTimeISO(Temporal.Now.timeZone()).epochMilliseconds.toString(36);
    }
    if (Object.prototype.toString.call(epochDateOrTemporal) === "[object Date]") {
        return (<Date>epochDateOrTemporal).getTime().toString(36);
    }
    if (Object.prototype.toString.call(epochDateOrTemporal) === "[object Temporal.ZonedDateTime]") {
        return (<Temporal.ZonedDateTime>epochDateOrTemporal).epochMilliseconds.toString(36);
    }
    return undefined;
}

export function parseTemporalFromEpochStr(epochStr: EpochStr): Temporal.ZonedDateTime {
    const epochMillis = parseInt(epochStr, 36)
    const parsedTemporal = Temporal.Instant.fromEpochMilliseconds(epochMillis).toZonedDateTimeISO(Temporal.Now.timeZone());
    if (parsedTemporal.epochSeconds == 0) throw new Error('Unable to parse temporal from ' + epochStr)
    return parsedTemporal
}

/**
* Get the type of an element. Not sure if I'll use this outside
* of the 
* @returns string representing the type of element
*/
export function getElementType(element: ElementData): 'DefData' | 'EntryData' | 'TagData' {
    if (element.hasOwnProperty("_tid") && element.hasOwnProperty("_dids")) return "TagData"
    if (element.hasOwnProperty("_eid")) return "EntryData"
    return "DefData"
}

//#endregion